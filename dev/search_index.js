var documenterSearchIndex = {"docs":
[{"location":"#Dispersal.jl","page":"Home","title":"Dispersal.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Dispersal","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dispersal","category":"page"},{"location":"#Dispersal.Dispersal","page":"Home","title":"Dispersal.Dispersal","text":"Dispersal\n\n(Image: ) (Image: ) (Image: CI) (Image: codecov.io)\n\n(Image: Spotted wing drosophola dispersal)\n\nA simulation of the spotted-wing drosophola invasion of the continental United  States as detailed in Maino, Schouten, and Umina (2021)\n\nDispersal.jl extends DynamicGrids.jl to provide model components and tools for grid-based simulations of organism dispersal.\n\nGrowth rates, dispersal kernels, Allee effects, and randomised jump and human assisted dispersal rules are provided. These components can be combined into complex dispersal models. Custom rules can easily added and combined with the provided set. See the documentation for examples and the lists of included rules.\n\nDynamicGridsInteract provides an interactive interface for atom and jupyter notbooks (InteractOuput), desktop (ElectronOutput) and online web applications (ServerOuput),  where complete models, including your custom rules, can be manipulated during live simulations.\n\nDynamicGridsGtk provides GtkOutput for a simple graphical viewer.\n\nGrowthMaps.jl can efficiently  generate summarised raster data for vital rates (e.g. intrinsic growth rates) based on  higher resolution and shorter interval environmental data.  \n\n\n\n\n\n","category":"module"},{"location":"#Neighborhood-Rules","page":"Home","title":"Neighborhood Rules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Rules that consider the neighborhood of cells surrounding the current cell. These disperse population inwards to the current cell when populations exist  in the surrounding cells.","category":"page"},{"location":"","page":"Home","title":"Home","text":"InwardsDispersal","category":"page"},{"location":"#Dispersal.InwardsDispersal","page":"Home","title":"Dispersal.InwardsDispersal","text":"InwardsPopulationDispersal <: NeighborhoodRule\n\nInwardsPopulationDispersal(; kw...)\nInwardsPopulationDispersal{R}(; kw...)\nInwardsPopulationDispersal{R,W}(; kw...)\n\nImplements deterministic dispersal from populations in neighboring cells to the current  cell.\n\nThe result should be identical to those obtained substituting InwardsDispersal for  OutwardsDispersal but will perform better when populations are spread across the grid.\n\nKeywords\n\nneighborhood: Any DynamicGrids.jl Neighborhood, or an   already constructed DispersalKernel. Using this keyword means radius is   ignored, and for a DispersalKernel, all other keywords are ignored.\nneighborhood: Neighborhood object specifying the range from the origin of the   discretised dispersal kernal. Defaults to Window(radius).\nformulation: kernel formulation object holding the exact form of the kernal.   Default ExponentialKernel.\ncellsize: the cell size of the discretised kernal (i.e. simulation grid size).   Default is 1.0.\ndistancemethod: DistanceMethod object for calculating distance between cells.   The default is CentroidToCentroid.\n\nPass grid Symbols to R or both R and W type parameters to use to specific grids.\n\n\n\n\n\n","category":"type"},{"location":"#Partial-Neighborhood-Rules","page":"Home","title":"Partial Neighborhood Rules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Partial neighborhood rules that disperse outwards to the neighborhood  when a local population exists in the current cell. These methods are harder to optimise and will generally have worse performance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"OutwardsDispersal","category":"page"},{"location":"#Dispersal.OutwardsDispersal","page":"Home","title":"Dispersal.OutwardsDispersal","text":"OutwardsPopulationDispersal <: SetNeighborhoodRule\n\nOutwardsPopulationDispersal(; kw...)\nOutwardsPopulationDispersal{R}(; kw...)\nOutwardsPopulationDispersal{R,W}(; kw...)\n\nImplements deterministic dispersal from the current cell to populations in neighboring cells.\n\nThis will make sense ecologically where cell populations are large, otherwise a randomised kernel may be more suitable.\n\nThe result should be identical to those obtained substituting OutwardsDispersal for InwardsDispersal but may be more efficient when a small number of cells are occupied. Conversely, it will become less efficient when a large proportion of the grid is occupied.\n\nKeywords\n\nneighborhood: Any DynamicGrids.jl Neighborhood, or an   already constructed DispersalKernel. Using this keyword means radius is   ignored, and for a DispersalKernel, all other keywords are ignored.\nneighborhood: Neighborhood object specifying the range from the origin of the   discretised dispersal kernal. Defaults to Window(radius).\nformulation: kernel formulation object holding the exact form of the kernal.   Default ExponentialKernel.\ncellsize: the cell size of the discretised kernal (i.e. simulation grid size).   Default is 1.0.\ndistancemethod: DistanceMethod object for calculating distance between cells.   The default is CentroidToCentroid.\n\nPass grid name Symbols to R and W type parameters to use specific grids.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal-kernels","page":"Home","title":"Dispersal kernels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kernels extend DynamicGrids.Neighborhood, and use neighbors() methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DispersalKernel\nKernelFormulation\nExponentialKernel","category":"page"},{"location":"#Dispersal.DispersalKernel","page":"Home","title":"Dispersal.DispersalKernel","text":"DispersalKernel <: AbstractKernel\n\nDispersalKernel(; kw...)\n\nDispersal kernel for taking the dot product of the neighborhood and a matching kernel of weights. May hold any Neighborhood object: the kernel will be built to match the shape, using the folumation, cellsize and distancemethod.\n\nKeyword Arguments\n\nneighborhood: Any DynamicGrids.jl Neighborhood, or an   already constructed DispersalKernel. Using this keyword means radius is   ignored, and for a DispersalKernel, all other keywords are ignored.\nneighborhood: Neighborhood object specifying the range from the origin of the   discretised dispersal kernal. Defaults to Window(radius).\nformulation: kernel formulation object holding the exact form of the kernal.   Default ExponentialKernel.\ncellsize: the cell size of the discretised kernal (i.e. simulation grid size).   Default is 1.0.\ndistancemethod: DistanceMethod object for calculating distance between cells.   The default is CentroidToCentroid.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.KernelFormulation","page":"Home","title":"Dispersal.KernelFormulation","text":"abstract type KernelFormulation\n\nKernelFormulation\n\nAbstract supertype for functors that calculate the probability density based on distance.\n\nConcrete implementations must define functor methods with the form:\n\n(k::SomeKernel)(distance) = # do something with `distance` and `k`\"\n\nUsing an anonymous function would not allow rebuildable model parameters.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.ExponentialKernel","page":"Home","title":"Dispersal.ExponentialKernel","text":"ExponentialKernel <: KernelFormulation\n\nExponentialKernel(λ)\n\nProbability density function of distance d.\n\ny = e^-dλ\n\nwhere λ is a shape parameter.\n\n\n\n\n\n","category":"type"},{"location":"#Distance-methods","page":"Home","title":"Distance methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Dispersal kernels can be calculated in a number of ways, giving different  properties and dispersal rates due to interactions between the cell size and the dispersal distance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DistanceMethod\nCentroidToCentroid\nAreaToCentroid\nAreaToArea","category":"page"},{"location":"#Dispersal.DistanceMethod","page":"Home","title":"Dispersal.DistanceMethod","text":"abstract type DistanceMethod\n\nDistanceMethod\n\nAbstract supertype for methods of calculating distances and discretised dispersal  probabilities between cells in a grid. between cells in a grid.\n\nDistance calculation methods include:\n\nCentroidToArea\nAreaToArea\nAreaToCentroid\n\nWhich are adapted from: \"On the approximation of continuous dispersal kernels  in discrete-space models, Joseph D. Chipperfield et al 2011\"\n\nThe CentroidToArea method has not been implemented.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.CentroidToCentroid","page":"Home","title":"Dispersal.CentroidToCentroid","text":"struct CentroidToCentroid <: DistanceMethod\n\nCentroidToCentroid <: DistanceMethod\n\nCentroidToCentroid()\n\nCalculates the discrete probability of dispersal between source and destination cell  centroids. This is the naive method, but it will not handle low grid resolution well  due to severe truncation.\n\nSee: \"On the approximation of continuous dispersal kernels in discrete-space models,  Joseph D. Chipperfield et al 2011\"\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.AreaToCentroid","page":"Home","title":"Dispersal.AreaToCentroid","text":"AreaToCentroid <: DistanceMethod\n\nAreaToCentroid(subsampling)\nAreaToCentroid(; subsampling=10.0)\n\nCalculates the discrete probability of dispersal between source cell area and destination centroid.\n\nSee: \"On the approximation of continuous dispersal kernels in discrete-space models,  Joseph D. Chipperfield et al 2011\"\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.AreaToArea","page":"Home","title":"Dispersal.AreaToArea","text":"AreaToArea <: DistanceMethod\n\nAreaToArea(subsampling)\nAreaToArea(; subsampling=10.0)\n\nCalculates the discrete probability of dispersal between source and destination based on  cell areas.\n\nSee: \"On the approximation of continuous dispersal kernels in discrete-space models,  Joseph D. Chipperfield et al 2011\"\n\n\n\n\n\n","category":"type"},{"location":"#Cell-rules","page":"Home","title":"Cell rules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Rules that simply transform the state of a single cell, ignoring the rest of the grid.","category":"page"},{"location":"#Growth-rules","page":"Home","title":"Growth rules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GrowthRule\nExponentialGrowth\nLogisticGrowth\nThresholdGrowth","category":"page"},{"location":"#Dispersal.GrowthRule","page":"Home","title":"Dispersal.GrowthRule","text":"Abstract supertype of CellRule for growth dynamics rules.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.ExponentialGrowth","page":"Home","title":"Dispersal.ExponentialGrowth","text":"ExponentialGrowth(; rate, timestep)\nExponentialGrowth{R}(; rate, timestep)\nExponentialGrowth{R,W}(; rate, timestep)\n\nExponential growth of population size N based on an intrinsic growth rate r, using the exact solution between timesteps t and t-1:\n\nN_t = N_t-1e^r t\n\nKeyword Arguments\n\nrate: Intrinsic growth rate. May be a Number, an Aux array or another Grid.\ntimestep: Time step for the growth rate calculation, in a type compatible with the simulation tspan.\n\nPass grid Symbols to R or both R and W type parameters to use to specific grids.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.LogisticGrowth","page":"Home","title":"Dispersal.LogisticGrowth","text":"LogisticGrowth(; rate, carrycap, timestep)\nLogisticGrowth{R}(; rate, carrycap, timestep)\nLogisticGrowth{R,W}(; rate, carrycap, timestep)\n\nLogistic growth rate of population size N based on an intrinsic growth rate r and carry capacity K, using the exact solution between timesteps t+1 and t:\n\nN_t+1 = (N_t K)  (N_t + (K - N_t) e^-rt)\n\nSaturation only applies with positive growth.\n\nKeyword Arguments\n\nrate: Growth rate. May be a Number, an Aux array or another Grid.\ncarrycap: Carrying capacity. May be a Number, an Aux array or another Grid.\ntimestep: Time step for the growth rate, in a type compatible with the simulation tspan.\n\nPass grid Symbols to R or both R and W type parameters to use to specific grids.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.ThresholdGrowth","page":"Home","title":"Dispersal.ThresholdGrowth","text":"ThresholdGrowth(; rate, threshold)\nThresholdGrowth{G}(; rate, threshold)\nThresholdGrowth{R,W}(; rate, threshold)\n\nSimple threshold mask. Values below a certain threshold are replaced with zero.\n\nKeyword Arguments\n\nrate: Growth rate. May be a Number, an Aux array or another Grid.\nthreshold: Minimum viability threshold below which population falls to zero.  \n\nMay be a Number, an Aux array or another Grid.\n\nPass grid Symbols to R or both R and W type parameters to use to specific grids.\n\n\n\n\n\n","category":"type"},{"location":"#Allee-effects","page":"Home","title":"Allee effects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AlleeExtinction","category":"page"},{"location":"#Dispersal.AlleeExtinction","page":"Home","title":"Dispersal.AlleeExtinction","text":"AlleeExtinction(minfounders)\nAlleeExtinction{R}(; minfounders=5.0)\nAlleeExtinction{R,W}(minfounders)\n\nCauses extinction in a cell when a population is below a minimum number of individuals.\n\nminfounders: minimum founding individuals required for a viable population. Must be a type that can be compared to the grid values using isless.\n\nPass grid Symbols to R or both R and W type parameters to use to specific grids.\n\n\n\n\n\n","category":"type"},{"location":"#Partial-Rules","page":"Home","title":"Partial Rules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These rules only partially update the grid. They often operate only on cells that are currently occupied.","category":"page"},{"location":"#Jump-dispersal","page":"Home","title":"Jump dispersal","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JumpDispersal","category":"page"},{"location":"#Dispersal.JumpDispersal","page":"Home","title":"Dispersal.JumpDispersal","text":"JumpDispersal(; prob_threshold, spotrange)\nJumpDispersal{R}(; prob_threshold, spotrange)\nJumpDispersal{R,W}(; prob_threshold, spotrange)\n\nJump dispersal simulates a random long distance dispersal event, which occurs at a given  probablity. A random cell within the spotrange is invaded by duplicating the entire   population of the source cell at the destination cell. \n\nKeyword Arguments\n\nprob_threshold: a real number between one and zero.\nspotrange: number of cells in range of jumps, in any direction.\n\nPass grid Symbols to R or both R and W type parameters to use to specific grids.\n\n\n\n\n\n","category":"type"},{"location":"#Human-driven-dispersal","page":"Home","title":"Human driven dispersal","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HumanDispersal\npopulate!\npopulate\ndownsample\ndownsample!","category":"page"},{"location":"#Dispersal.HumanDispersal","page":"Home","title":"Dispersal.HumanDispersal","text":"HumanDispersal{R,W}(; mode=BatchGroups(),\n                      human_pop,\n                      cellsize=1.0,\n                      scale=4,\n                      aggregator=mean,\n                      human_exponent=1.0,\n                      dist_exponent=1.0,\n                      dispersalperpop=1e-3,\n                      max_dispersers=100.0,\n                      nshortlisted=100)\n\nImplements human-driven dispersal patterns using population density data.\n\nThe number of long-distance migrants from an origin is set proportional to the level of   human population with the coefficient dispersalperpop. The destination of long-distance   migration is is calculated by using the distance d between and human population H  at origin cell i and destination cell j through a simple gravity function:\n\ng_ij = (H_i H_j)^β(d_ij)^γ\n\nwhere β (human_exponent) and γ (dist_exponent) are parameters. For each grid cell, a   shortlist of size nshortlisted of the destination cells with the highest gravity are   selected for use in the simulation.\n\nThe time taken for precalulation will depend on the scale argument. Values above 1 will downsample the grid to improve precalulation time and runtime performance. A high scale value is good for use in a live interface.\n\nKeyword Arguments\n\nmode: Dispersal mode: Defaults to BatchGroups(), otherwise HeirarchicalGroups().\nhuman_pop: An array match the grid size containing human population data.\ncellsize: The size of the cell width, assuming they are square\nscale: Downscaling factor to reduce memory use and improve performance, defaults to 4  \n\nwhich means a 1:16 ratio.\n\naggregator: a function that aggregates cells, defualting to mean.\nhuman_exponent: human population exponent.\ndist_exponent: distance exponent.\ndispersalperpop: sets the number of dispersing individuals from the origin as a  \n\nproportion of the level of human activity.\n\nmax_dispersers: maximum number of dispersers in a single dispersal event.\nnshortlisted: length of the dispersal destination shortlist for each cell.  Longer lists are more accurate in the tail of the distribution, but are slower to access.\n\nPass grid Symbols to R or both R and W type parameters to use to specific grids.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.populate!","page":"Home","title":"Dispersal.populate!","text":"populate!(A::AbstractMatrix, rule::HumanDispersal, [I...])\npopulate!(A::AbstractMatrix, cells::AbstractArray, [scale=1])\n\nPopulate a matrix with the precalculated destinations from a HumanDispersal rule - either all of the or some subset if passed the I... indexing arguments. This is useful for plotting dispersal destinations, especially when used with GeoData.jl\n\n\n\n\n\n","category":"function"},{"location":"#Dispersal.populate","page":"Home","title":"Dispersal.populate","text":"populate(rule::HumanDispersal, [I...])\n\nReturns an array the size of human population matrix filled with all destination locataion, or with destinations specific to the passed-in indices I.\n\n\n\n\n\npopulate(cells::AbstractVector, size::Tuple, [scale::Int=1])\n\nReturns an array of size size populated from the vector of positions in cells rescaled by scale.\n\n\n\n\n\n","category":"function"},{"location":"#Dispersal.downsample","page":"Home","title":"Dispersal.downsample","text":"downsample(a::AbstractMatrix, aggregator, scale)\n\nAllocates a new output array and run downsample!.\n\n\n\n\n\n","category":"function"},{"location":"#Dispersal.downsample!","page":"Home","title":"Dispersal.downsample!","text":"downsample!(out::AbstractMatrix, a::AbstractMatrix, aggregator, scale)\n\nDownsamples matrix a to another matrix out of the correct size.\n\naggregator is a function such as mean or sum that can combine the    value of multiple cells to generate the downsampled cell.\nscale is the downsampling factor.\n\n\n\n\n\n","category":"function"},{"location":"example/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"author: \"Rafael Schouten\" title: \"Dispersal.jl example\" –-","category":"page"},{"location":"example/#Dispersal-simulations","page":"Examples","title":"Dispersal simulations","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"In this example we will run a simulation of the spread of the Spotted Winged Drosophila D. suzukii accross the continental USA.","category":"page"},{"location":"example/#Setup","page":"Examples","title":"Setup","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"First, load the required packages. Dates is a core julia package that give us date/time handling, GeoData simplifies the loading of geospatial raster files. It requires also loading NCDatasets.jl and ArchGDAL.jl to load NetCDF and GeoTiff files, respectively.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"# using Pkg\n# Pkg.add(PackageSpec(url=\"https://github.com/rafaqz/GeoData.jl\", rev=\"master\"))\n\nusing GeoData, DimensionalData, Dispersal, Dates, NCDatasets, ArchGDAL, Plots\nusing DimensionalData: rebuild, Forward, Reverse\nbasedir = joinpath(dirname(Base.pathof(Dispersal)), \"../docs\")","category":"page"},{"location":"example/#Define-simulation-extent-in-space-and-time:","page":"Examples","title":"Define simulation extent in space and time:","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"We use DateTime of for the time dimension:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"timestep = Month(1);\ntspan = DateTime(2016, 1):Month(1):DateTime(2018, 12)\naust = Lon(Between(113.338953078, 153.569469029)),\n       Lat(Between(-43.6345972634, -10.6681857235));","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"example/#Define-a-RuleSet:-climate-driven-population-growth","page":"Examples","title":"Define a RuleSet: climate driven population growth","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"This will involve combining multiple dispersal components into a single RuleSet object: population growth, local dispersal, Allee effects, and human dispersal.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Follow the examples tutorial over at GrowthRates.jl. To skip this step just download the output saved in the example:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"dataurl = \"https://media.githubusercontent.com/media/cesaraustralia/Dispersal.jl/data\"\ngrowthratesfilename = \"growthrates.ncd\"\ngrowthratesfilepath = joinpath(basedir, growthratesfilename)\nisfile(growthratesfilepath) ||\n  download(joinpath(dataurl, growthratesfilename), joinpath(basedir, growthratesfilename));","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"And select just the bounding box for Australia, and set the dimension order to Lat/Lon:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"growthrates = NCDarray(growthratesfilepath)\n# Set the length of the timestep. TODO: get this automatically from NetCDF units in GeoData.jl\nmode_ = Sampled(DimensionalData.order(ti), Regular(timestep), Intervals(Start()))\ngrowthrates = set(growthrates, Ti=mode_);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Plot the growth layer:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"growthrates[Ti(1)] |> plot\nsavefig(joinpath(basedir, \"build/assets/growthrates.png\"));","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Create a ExactLogisticGrowthMap rule from the layer, here we use unitful units for the layers' time dimension:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"carrycap = 1e9\ngrowth = ExactLogisticGrowthMap(layerkey=:growthrates, carrycap=carrycap);","category":"page"},{"location":"example/#Local-dispersal","page":"Examples","title":"Local dispersal","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"λ = 0.0125\nradius = 1\nsze = 2radius + 1\ndm = AreaToArea(30)\n@time hood = DispersalKernel{radius}(;\n    kernel=zeros(Float64, radius, radius),\n    formulation=ExponentialKernel(λ),\n    distancemethod=dm\n)\nlocaldisp = InwardsPopulationDispersal(hood);","category":"page"},{"location":"example/#Allee-effects","page":"Examples","title":"Allee effects","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"allee = AlleeExtinction(minfounders=10.0);","category":"page"},{"location":"example/#Human-dispersal","page":"Examples","title":"Human dispersal","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"The human dispersal component is generated from an array or population data. First we'll open an input tiff, and move it to a memory backed GeoArray.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"humanpop_filename = \"population_density.tif\"\nhumanpop_filepath = joinpath(basedir, humanpop_filename)\nisfile(humanpop_filepath) || download(joinpath(dataurl, humanpop_filename), humanpop_filepath);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Again select the Australian bounds. This time we also select the first Band. Tiff data always has bands, even when there is only one:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"humanpop = GDALarray(humanpop_filepath; usercrs=EPSG(4326))[Band(1), aust...] |>\n    A -> permutedims(A, (Lat, Lon)) |> reorderarray\nsavefig(joinpath(basedir, \"build/assets/humanpop.png\"));","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"(Image: popgrowth)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"@time humandisp = HumanDispersal(\n    human_pop=parent(humanpop),\n    human_exponent=2.0,\n    dist_exponent=2.0,\n    dispersalperpop=1e-9,\n    max_dispersers=500.0,\n    nshortlisted=50,\n    scale=8,\n);","category":"page"},{"location":"example/#Define-initialisation-data","page":"Examples","title":"Define initialisation data","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"Make a zeros array and populate the starting cells. We need to replace the missing values with something else Dispersal.jl init can't contain missing or it will spread everywhere:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"init = replace_missing(growthrates[Ti(1)], NaN) |> zero\nincursion = [(36.9677, -122.0294),\n             (37.3226, -121.8921),\n             (37.6008, -120.9545),\n             (35.3453, -119.0586),\n             (38.7318, -121.9014),\n             (38.5249, -121.9708),\n             (37.2502, -119.751)]\n# Using `Contains` finds the interval that contains the coordinates\nfor (lat, lon) in incursion\n    init[Lat(Contains(lat)), Lon(Contains(lon))] = 1e7\nend","category":"page"},{"location":"example/#Define-a-masking-layer","page":"Examples","title":"Define a masking layer","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"This layer lets the simulation know which cells should be ignored.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"masklayer = boolmask(growthrates[Ti(1)])\nplot(masklayer)\nsavefig(joinpath(basedir, \"build/assets/mask.png\"));","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"(Image: mask)","category":"page"},{"location":"example/#Define-a-combined-ruleset","page":"Examples","title":"Define a combined ruleset","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"ruleset = Ruleset(\n    humandisp, Chain(localdisp, allee, growth);\n    timestep=timestep,\n);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"example/#Output","page":"Examples","title":"Output","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"The simplest and oftern the most performant output for a simulation is an ArrayOutput, which simply writes the simulation to a preallocated array without visualising it.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"output = ArrayOutput(init;\n    tspan=tspan,\n    mask=masklayer,\n    aux=(growthrates=growthrates,),\n    minval=0.0,\n    maxval=carrycap,\n);","category":"page"},{"location":"example/#Run-a-simulation","page":"Examples","title":"Run a simulation","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"To run a simulation, we pass in the output and rulset.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"sim!(output, ruleset);","category":"page"},{"location":"example/#Save-a-gif-of-your-simulation","page":"Examples","title":"Save a gif of your simulation","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"Gif files are an easy way to share the visual dynamics of the simulation. First we need to define a color processor to turn the simulation into images for the frames of the the gif. This processor can also be used later in web or gtk outputs.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"You can use the built-in Greyscale scheme, or any scheme from ColorSchemes.jl.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using ColorSchemes, Colors\nscheme = ColorSchemes.Oranges_3\n#scheme = ColorSchemes.autumn1\n\n## Frame Processing Colors\nzerocolor = RGB24(0.7)\nmaskcolor = RGB24(0.0)\ntextconfig = TextConfig(font=\"arial\")\nprocessor = ColorProcessor(scheme, zerocolor, maskcolor, textconfig);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"With a non-image output like ArrayOuput we need to pass in the image processor manually.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"savegif(joinpath(basedir, \"build/assets/sim.gif\"), output; minval=0.0, maxval=1e7, processor=processor, fps=10);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"(Image: Drosphila suzukii spread)","category":"page"},{"location":"example/#Live-simulation-outputs","page":"Examples","title":"Live simulation outputs","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"There are a number of live outputs provided in CelularAutomataBase.jl and specific output packages DynamicGridsGtk and DynamicGridsInteract that keep heavy graphics and web dependencies separate form the rest of the framework.","category":"page"},{"location":"example/#REPL-output","page":"Examples","title":"REPL output","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"You can view a simulation over SSH or just in your local console using the included REPLOutput. It doesn't work so well in Atom/Juno, so we only recommend using it in a real terminal. It also works better in a terminal where you can easily reduce the font size.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using Crayons\noutput = REPLOutput(init; tspan=tspan, style=Block(), fps=5, color=:white, store=false)\nsim!(output, ruleset);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The Braile() style is half the dimensions of the Block() style, but doen't look as clear.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"output = REPLOutput(init; tspan=tspan, style=Braile(), fps=5, color=:white, store=false)\nsim!(output, ruleset);","category":"page"},{"location":"example/#Interactive-web-outputs","page":"Examples","title":"Interactive web outputs","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"DynamicGridsInteract.jl produces interactive web page outputs for a simulation. It uses Interact.jl for live control, providing a control console and sliders for model parameters, even for your own custom models.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The simple InteractOutput() is the core output that can run on its own inside Juno or a Jupyter notebook. It can also be served to a browser locally or over the web using ServerOutput(), or run in a standalone desktop app using ElectronOutput().","category":"page"},{"location":"example/#Juno-or-jupyter-notebooks","page":"Examples","title":"Juno or jupyter notebooks","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"Building a InteractOutput() and running display() will open an output in a plot pane in Juno. See the example above to define an image processor. Setting store to true will save the last simulation to the output array to be saved or converted to a gif. Really long simulations may use your avilable ram, in which case set store to false.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using DynamicGridsInteract\noutput = InteractOutput(init, ruleset;\n    ruleset=ruleset,\n    tspan=tspan,\n    fps=10,\n    store=true,\n    processor=processor,\n    slider_throttle=1.0,\n)\ndisplay(output)","category":"page"},{"location":"example/#Wrap-the-IneractOutput-in-a-standalone-desktop-(electron)-app","page":"Examples","title":"Wrap the IneractOutput in a standalone desktop (electron) app","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"This will create a standalone desktop app wrapping the InteractOutput. Unfortunately the compile and load time for electron can take quite a while.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"output = ElectronOutput(init;\n    ruleset=ruleset,\n    tspan=tspan,\n    fps=10,\n    store=true,\n    processor=processor,\n    slider_throttle=1.0,\n)","category":"page"},{"location":"example/#Serving-web-pages","page":"Examples","title":"Serving web pages","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"The InteractOutput can be served locally or over the web. You may need to do some port or firewall configuration on your server, but otherwise this is all you need to do to serve a simulation. Unlike other outputs, ServerOutput makes a copy of the internal InteractOutput for each new connection. Changes in one connection will not effect anything in the others.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"output = ServerOutput(init;\n    ruleset=ruleset,\n    tspan=tspan,\n    fps=10,\n    processor=processor,\n    slider_throttle=1.0,\n    port=8080,\n)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"If run locally, the interface should be served at the address \"localhost:8080\" in your web browser.","category":"page"},{"location":"example/#Run-in-a-GTK-window","page":"Examples","title":"Run in a GTK window","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"The GTKOutput in DynamicGridsGtk.jl is a simple desktop output that just shows the simulation without controls. It can be useful for faster load-time than ElectronOutput, and also dedicates all screenspace to viewing the simulation.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using DynamicGridsGtk\noutput = GtkOutput(init .* 0;\n    mask=masklayer,\n    tspan=tspan,\n    fps=10,\n    store=true,\n    processor=processor\n)\nsim!(output, ruleset)","category":"page"}]
}
