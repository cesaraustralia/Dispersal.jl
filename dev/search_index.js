var documenterSearchIndex = {"docs":
[{"location":"#Dispersal.jl","page":"Home","title":"Dispersal.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Dispersal","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dispersal","category":"page"},{"location":"#Dispersal.Dispersal","page":"Home","title":"Dispersal.Dispersal","text":"Dispersal\n\n(Image: ) (Image: ) (Image: Build Status) (Image: codecov.io)\n\n(Image: Spotted wing drosophola dispersal)\n\nFitted dispersal simulation of the spotted-wing drosophola invasion of continental USA.\n\nDispersal.jl extends DynamicGrids.jl for grid-based simulations of organism dispersal.\n\nGrowth rates, dispersal kernels, Allee effects, and randomised jump and human assisted dispersal rules are provided. These components can be combined into complex dispersal models. Custom rules can easily added and combined with the provided set. See the documentation for examples and the lists of included rules.\n\nDynamicGridsInteract provides an interactive interface for atom and jupyter notbooks (InteractOuput), desktop (ElectronOutput) and online web applications (ServerOuput),  where complete models, including your custom rules, can be manipulated during live simulations.\n\nDynamicGridsGtk provides GtkOutput for a simple graphical viewer.\n\nGrowthMaps.jl can efficiently generate the layers required for growth rules based on temperature response and stress factors.\n\n\n\n\n\n","category":"module"},{"location":"#Neighborhood-Rules","page":"Home","title":"Neighborhood Rules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Rules that consider the neighborhood of cells surrounding the current cell. These disperse population inwards to the current cell when populations exist  in the surrounding cells.","category":"page"},{"location":"","page":"Home","title":"Home","text":"InwardsDispersal\nInwardsBinaryDispersal\nInwardsPopulationDispersal","category":"page"},{"location":"#Dispersal.InwardsDispersal","page":"Home","title":"Dispersal.InwardsDispersal","text":"abstract type InwardsDispersal <: NeighborhoodRule{R,W}\n\nAbstract supertype that extends NeighborhoodRule for neighborhood-based dispersal rules that update a cell based on the values of the surounding cells, as if dispersing inwards to the current cell.\n\nThe result should be identical to the matching OutwardsDispersal methods.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.InwardsBinaryDispersal","page":"Home","title":"Dispersal.InwardsBinaryDispersal","text":"InwardsBinaryDispersal(neighborhood)\nInwardsBinaryDispersal(; neighborhood=DispersalKernel{3}())\nInwardsBinaryDispersal{R,W}(neighborhood)\n\nBinary present/absent dispersal within a DispersalKernel. Inwards dispersal calculates dispersal to the current cell from cells in the neighborhood.\n\nThe current cell is invaded if there is pressure from surrounding cells and suitable habitat. Otherwise it keeps its current state.\n\nPass grid name Symbols to R and W type parameters to use specific grids.\n\nField Description Default Bounds\nprob_threshold A real number between one and zero 0.1 (0.0, 1.0)\nneighborhood Normalised proportions of dispersal to surrounding cells DispersalKernel{3,ExponentialKernel{Floa (0.0, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.InwardsPopulationDispersal","page":"Home","title":"Dispersal.InwardsPopulationDispersal","text":"InwardsPopulationDispersal(neighborhood)\nInwardsPopulationDispersal(; neighborhood=DispersalKernel{3}())\nInwardsPopulationDispersal{R,W}(neighborhood)\n\nDisperses to the current cells from the populations of the surrounding cells, using a dispersal kernel deterministically.\n\nThis will only make sense where cell populations are large.\n\nPass grid name Symbols to R and W type parameters to use specific grids.\n\nField Description Default Bounds\nneighborhood Normalised proportions of dispersal to surrounding cells DispersalKernel{3,ExponentialKernel{Floa (0.0, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"#Partial-Neighborhood-Rules","page":"Home","title":"Partial Neighborhood Rules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Partial neighborhood rules that disperse outwards to the neighborhood  when a local population exists in the current cell. These methods are harder to optimise and will generally have worse performance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"OutwardsDispersal\nOutwardsBinaryDispersal\nOutwardsPopulationDispersal","category":"page"},{"location":"#Dispersal.OutwardsDispersal","page":"Home","title":"Dispersal.OutwardsDispersal","text":"abstract type OutwardsDispersal <: ManualNeighborhoodRule{R,W}\n\nAbstract supertype that extends ManualNeighborhoodRule for neighborhood-based  dispersal rules that update surounding cells based on the values of the  current cell, as if dispersing outwards from the current cell.\n\nThe result should be identical to InwardsDispersal but may be more  efficient than when a small number of cells are occupied. It is less efficient  when a large proportion of the grid is occupied.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.OutwardsBinaryDispersal","page":"Home","title":"Dispersal.OutwardsBinaryDispersal","text":"OutwardsBinaryDispersal(neighborhood)\nOutwardsBinaryDispersal(; neighborhood=DispersalKernel{3}())\nOutwardsBinaryDispersal{R,W}(neighborhood)\n\nCells in the surrounding neighborhood have some propability of  invasion if the current cell is occupied.\n\nPass grid name Symbols to R and W type parameters to use specific grids.\n\nField Description Default Bounds\nneighborhood Normalised proportions of dispersal to surrounding cells DispersalKernel{3,ExponentialKernel{Floa (0.0, 1.0)\nprob_threshold A real number between one and zero 0.1 (0.0, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.OutwardsPopulationDispersal","page":"Home","title":"Dispersal.OutwardsPopulationDispersal","text":"OutwardsPopulationDispersal(neighborhood)\nOutwardsPopulationDispersal(; neighborhood=DispersalKernel{3}())\nOutwardsPopulationDispersal{R,W}(neighborhood)\n\nDispersal reduces the current cell population, increasing the populations of the  cells in the surrounding neighborhood.\n\nPass grid name Symbols to R and W type parameters to use specific grids.\n\nField Description Default Bounds\nneighborhood Normalised proportions of dispersal to surrounding cells DispersalKernel{3,ExponentialKernel{Floa (0.0, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal-kernels","page":"Home","title":"Dispersal kernels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kernels extend DynamicGrids.Neighborhood, and use neighbors() methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DispersalKernel\nKernelFormulation\nExponentialKernel","category":"page"},{"location":"#Dispersal.DispersalKernel","page":"Home","title":"Dispersal.DispersalKernel","text":"DispersalKernel{Radius}(formulation::F, kernel::K, cellsize::C, distancemethod::D)\nDispersalKernel{Radius}(; formulation=ExponentialKernel(1.0), cellsize=1.0, distancemethod=CentroidToCentroid())\n\narguments, but preferably use the keyword constructor to build the array from a dispersal kernel function.\n\nField Description Default Bounds\nformulation Kernel formulation object ExponentialKernel{Float64}(1.0) (0.0, 1.0)\nkernel Kernal matrix nothing (0.0, 1.0)\ncellsize Simulation cell size 1.0 (0.0, 10.0)\ndistancemethod Method for calculating distance between cells CentroidToCentroid() (0.0, 1.0)\nbuffer Neighborhood buffer nothing (0.0, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.KernelFormulation","page":"Home","title":"Dispersal.KernelFormulation","text":"abstract type KernelFormulation\n\nAbstract supertype for functors for calculating the probability of  dispersal between two points.\n\nConcrete implementations must define functor methods with the form:\n\n(k::SomeKernel)(x) = ? # do something with `x` and `k`\"\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.ExponentialKernel","page":"Home","title":"Dispersal.ExponentialKernel","text":"ExponentialKernel(λ)\n\nProbability of dispersal with a negatitve exponential relationship to distance.\n\nField Description Default Bounds\nλ Parameter for adjusting spread of dispersal propability 1.0 (0.0, 2.0)\n\n\n\n\n\n","category":"type"},{"location":"#Distance-methods","page":"Home","title":"Distance methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Dispersal kernels can be calculated in a number of ways, giving different  properties and dispersal rates due to interactions between the cell size and the dispersal distance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DistanceMethod\nCentroidToCentroid\nAreaToCentroid\nAreaToArea","category":"page"},{"location":"#Dispersal.DistanceMethod","page":"Home","title":"Dispersal.DistanceMethod","text":"abstract type DistanceMethod\n\nAbstract supertype for methods of calculating distances and dispersal probabilities between cells in a grid.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.CentroidToCentroid","page":"Home","title":"Dispersal.CentroidToCentroid","text":"struct CentroidToCentroid <: DistanceMethod\n\nCentroidToCentroid()\n\nCalculates probability of dispersal between source and destination cell centroids This is the obvious, naive method, but it will not handle low grid resolution well.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.AreaToCentroid","page":"Home","title":"Dispersal.AreaToCentroid","text":"AreaToCentroid(subsampling)\nAreaToCentroid(; subsampling=10.0)\n\nCalculates probability of dispersal between source cell area and destination centroid.\n\nField Description Default Bounds\nsubsampling Subsampling for brute-force integration 10.0 (2.0, 40.0)\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.AreaToArea","page":"Home","title":"Dispersal.AreaToArea","text":"struct AreaToArea <: DistanceMethod\n\nAreaToArea(subsampling)\nAreaToArea(; subsampling=10.0)\n\nCalculates probability of dispersal between source and destination cell areas.\n\nField Description Default Bounds\nsubsampling  nothing (0.0, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"#Cell-rules","page":"Home","title":"Cell rules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Rules that simply transform the state of a single cell, ignoring the rest of the grid.","category":"page"},{"location":"#Growth-rules","page":"Home","title":"Growth rules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GrowthRule\nExactExponentialGrowth\nExactLogisticGrowth\nGrowthMapRule\nExactExponentialGrowthMap\nExactLogisticGrowthMap\nMaskGrowthMap","category":"page"},{"location":"#Dispersal.GrowthRule","page":"Home","title":"Dispersal.GrowthRule","text":"abstract type GrowthRule <: CellRule{R,W}\n\nExtends CellRule for rules of growth dynamics\n\nFor best performance these should be chained with other CellRule or following an NeighborhoodRule.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.ExactExponentialGrowth","page":"Home","title":"Dispersal.ExactExponentialGrowth","text":"Simple fixed exponential growth rate using exact solution.\n\nField Description Default Bounds\nintrinsicrate Intrinsic rate of growth per timestep 0.1 (0.0, 10.0)\ntimestep Timestep converted from sim data. Needs to be separate from rate for DateTime nothing (0.0, 1.0)\nnsteps The exact nsteps timestep, updated by precalcrule 1.0 (0.0, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.ExactLogisticGrowth","page":"Home","title":"Dispersal.ExactLogisticGrowth","text":"Simple fixed logistic growth rate using exact solution\n\nField Description Default Bounds\nintrinsicrate Intrinsic rate of growth per timestep 0.1 (0.0, 10.0)\ncarrycap Carrying capacity for each cell. Not currently scaled by area. 100000.0 (0.0, 1.0e9)\ntimestep Timestep converted from sim data. Needs to be separate from rate for DateTime nothing (0.0, 1.0)\nnsteps The exact nsteps timestep, updated by precalcrule 1.0 (0.0, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.GrowthMapRule","page":"Home","title":"Dispersal.GrowthMapRule","text":"abstract type GrowthMapRule <: Dispersal.GrowthRule{R,W}\n\nExtends GrowthRule for growth rules using a heterogenous growth rate layer.\n\nGrowthMaps.jl can produce these growth maps from environmental data.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.ExactExponentialGrowthMap","page":"Home","title":"Dispersal.ExactExponentialGrowthMap","text":"Exponential growth based on a growth rate layer using exact solution.\n\nField Description Default Bounds\ntimestep Timestep converted from sim data. Needs to be separate from rate for DateTime nothing (0.0, 1.0)\nnsteps The exact nsteps timestep, updated by precalcrule 1.0 (0.0, 1.0)\nlayerkey key for aux layer nothing (0.0, 1.0)\ntimeindex Precalculated interpolation indices. Not set by users 1 (0.0, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.ExactLogisticGrowthMap","page":"Home","title":"Dispersal.ExactLogisticGrowthMap","text":"Logistic growth based on a growth rate layer, using exact solution.\n\nSaturation only applies with positive growth\n\nField Description Default Bounds\nlayerkey key for aux layer nothing (0.0, 1.0)\ntimeindex Precalculated interpolation indices. Not set by users 1 (0.0, 1.0)\ntimestep Timestep converted from sim data. Needs to be separate from rate for DateTime nothing (0.0, 1.0)\nnsteps The exact nsteps timestep, updated by precalcrule 1.0 (0.0, 1.0)\ncarrycap Carrying capacity for each cell. Not currently scaled by area. 100000.0 (0.0, 1.0e9)\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.MaskGrowthMap","page":"Home","title":"Dispersal.MaskGrowthMap","text":"Simple layer mask. Values below a certain threshold are replaced with zero.\n\nField Description Default Bounds\nthreshold Minimum viability index. 0.5 (0.0, 1.0)\nlayerkey key for aux layer nothing (0.0, 1.0)\ntimeindex Precalculated interpolation indices. Not set by users 1 (0.0, 1.0)\ntimestep Timestep converted from sim data. Needs to be separate from rate for DateTime nothing (0.0, 1.0)\nnsteps The exact nsteps timestep, updated by precalcrule 1.0 (0.0, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"#Allee-effects","page":"Home","title":"Allee effects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AlleeExtinction","category":"page"},{"location":"#Dispersal.AlleeExtinction","page":"Home","title":"Dispersal.AlleeExtinction","text":"AlleeExtinction(minfounders)\nAlleeExtinction(; minfounders=5.0)\nAlleeExtinction{R,W}(minfounders)\n\nCauses extinction in a cell when a population is below the  minimum number of individuals required to maintain it. \n\nPass grid name Symbols to R and W type parameters to use specific grids.\n\nField Description Default Bounds\nminfounders Minimum founding individuals required to to start an ongoing population 5.0 (1.0, 200.0)\n\n\n\n\n\n","category":"type"},{"location":"#Partial-Rules","page":"Home","title":"Partial Rules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These rules only partially update the grid. They often operate only on cells that are currently occupied.","category":"page"},{"location":"#Jump-dispersal","page":"Home","title":"Jump dispersal","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JumpDispersal","category":"page"},{"location":"#Dispersal.JumpDispersal","page":"Home","title":"Dispersal.JumpDispersal","text":"JumpDispersal(spotrange)\nJumpDispersal{R,W}(spotrange)\nJumpDispersal(; spotrange=30.0)\n\nJump dispersal simulates random long distance dispersal events. A random cell within  the spotrange is invaded. \n\nPass grid name Symbols to R and W type parameters to use specific grids.\n\nField Description Default Bounds\nspotrange A number or Unitful.jl distance with the same units as cellsize 30.0 (0.0, 100.0)\nprob_threshold A real number between one and zero 0.1 (0.0, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"#Human-driven-dispersal","page":"Home","title":"Human driven dispersal","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HumanDispersal\npopulate!\npopulate\ndownsample\ndownsample!","category":"page"},{"location":"#Dispersal.HumanDispersal","page":"Home","title":"Dispersal.HumanDispersal","text":"HumanDispersal{R,W}(mode, human_pop, cellsize, scale, aggregator, human_exponent,\n                    dist_exponent, dispersalperpop, max_dispersers, nshortlisted,\n                    dest_shortlists, proportion_covered, human_buffer, distances)\nHumanDispersal(; read=:_default_, write=read,\n               mode=BatchGroups(),\n               human_pop,\n               cellsize=1.0,\n               scale=4,\n               aggregator=mean,\n               human_exponent=1.0,\n               dist_exponent=1.0,\n               dispersalperpop=1e-3,\n               max_dispersers=100.0,\n               nshortlisted=100)\n\nHuman-driven dispersal patterns using population data.\n\nTransport connections between grid cells are calculated using distance and human population, modified with the human_exponent and dist_exponent parameters. A shortlist of the most connected cells is selected for use in the simulation.\n\nThe time taken for precalulation will depend on the scale argument. Values above 1 will downsample the grid to improve precalulation time and runtime performance. A high scale value is good for use in a live interface.\n\nKeyword Arguments\n\nField Description Default Bounds\nmode Dispersal mode nothing (0.0, 1.0)\nhuman_pop An array match the grid size containing human population data. nothing (0.0, 1.0)\ncellsize The size of the cell width, assuming they are square nothing (0.0, 1.0)\nscale  nothing (0.0, 1.0)\naggregator A function that aggregates scaled down cells nothing (0.0, 1.0)\nhuman_exponent Human population exponent nothing (1.0, 3.0)\ndist_exponent Distance exponent nothing (1.0, 3.0)\ndispersalperpop Scales the number of dispersing individuals by human activity (ie population^human_exponent) nothing (0.0, 1.0e-8)\nmax_dispersers Maximum number of dispersers in a dispersal events nothing (50.0, 10000.0)\nnshortlisted Length of dest shortlist nothing (0.0, 1.0)\ndest_shortlists Array of destination vectors for each cell. Automatically calculated nothing (0.0, 1.0)\nhuman_buffer Buffer array used in precalculation nothing (0.0, 1.0)\ndistances Buffer array used in precalculation nothing (0.0, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.populate!","page":"Home","title":"Dispersal.populate!","text":"populate!(A::AbstractMatrix, rule::HumanDispersal, [I...])\npopulate!(A::AbstractMatrix, cells::AbstractArray, [scale=1])\n\nPopulate a matrix with the precalculated destinations from a HumanDispersal rule - either all of the or some subset if passed the I... indexing arguments. This is useful for plotting dispersal destinations, especially when used with GeoData.jl\n\n\n\n\n\n","category":"function"},{"location":"#Dispersal.populate","page":"Home","title":"Dispersal.populate","text":"populate(rule::HumanDispersal, [I...])\n\nReturns an array the size of human population matrix filled with all destination locataion, or with destinations specific to the passed-in indices I.\n\n\n\n\n\npopulate(cells::AbstractVector, size::Tuple, [scale::Int=1])\n\nReturns an array of size size populated from the vector of positions in cells rescaled by scale.\n\n\n\n\n\n","category":"function"},{"location":"#Dispersal.downsample","page":"Home","title":"Dispersal.downsample","text":"downsample(a::AbstractMatrix, aggregator, scale)\n\nAllocate a new output array and run downsample!.\n\n\n\n\n\n","category":"function"},{"location":"#Dispersal.downsample!","page":"Home","title":"Dispersal.downsample!","text":"downsample!(out::AbstractMatrix, a::AbstractMatrix, aggregator, scale)\n\nDownsample matrix a to another matrix out of the correct size.\n\naggregator is a function such as mean or sum that can combine the    value of multiple cells to generate the downsampled cell.\nscale is the downsampling factor.\n\n\n\n\n\n","category":"function"},{"location":"#Layer","page":"Home","title":"Layer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"layer\nLayerCopy","category":"page"},{"location":"#Dispersal.layer","page":"Home","title":"Dispersal.layer","text":"layer(rule::Rule, data::SimData, [I...])\n\nReturns the value of a single layer or interplated value from a sequence of layers.\n\nIf multiple layers are available the product will be returned. Corresponding layers must be include in the aux NamedTuple in the out put or passed to sim!\n\n\n\n\n\n","category":"function"},{"location":"#Dispersal.LayerCopy","page":"Home","title":"Dispersal.LayerCopy","text":"LayerCopy(layerkey, timeindex)\n\nA simple rule that copies a layer to a grid over time.  This can be used for comparing simulation dynamics to layer dynamics.\n\nField Description Default Bounds\nlayerkey key for aux layer nothing (0.0, 1.0)\ntimeindex Precalculated interpolation indices. Not set by users 1 (0.0, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"#Optimisation","page":"Home","title":"Optimisation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Dispersal.jl provides optimisation tools for automatically optimising  the parameters of arbitrary rulesets, given target data. Objective  can be extended to add specific objection functions to transform simulation outputs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Parametriser\nObjective\nSimpleObjective\nRegionObjective\nRegionOutput\nColorRegionFit\nReplicates\nDistributedReplicates\nSingleCoreReplicates\nThreadedReplicates\ntargets\npredictions","category":"page"},{"location":"#Dispersal.Parametriser","page":"Home","title":"Dispersal.Parametriser","text":"struct Parametriser{RU, OP, OB, TR, L, NR, GS, TH, D, TB, PB, RE}\n\nParametriser(ruleset, output, objective, transform, loss, ngroups, groupsize, \n             tspan, threading)\n\nParametrizer functor to use with Optim.jl or similar.\n\nArguments\n\nruleset::Ruleset: simulation ruleset, with init array attached\noutput::Output: optional output type. By default an ArrayOutput will be generated.\nobjective::Objective: objective data\ntransform: single argument function to transform targets and predictions before the loss function\nloss: LossFunctions.jl loss function\nngroups::Int: number of replicate simulation\ngroupsize::Int: number of simulations in a group. Larger groups may inprove distributed performance.\nthreading::Replicates: Type to define threading mode for simulation replicates:  SingleCoreReplicates, ThreadedReplicates, DistributedReplicates\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.Objective","page":"Home","title":"Dispersal.Objective","text":"abstract type Objective\n\nAbstract supertype. Objectives map simulation outputs to predictions  that can be compared to target data using a loss function.\n\nThey must implement predictionsand targets methods.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.SimpleObjective","page":"Home","title":"Dispersal.SimpleObjective","text":"struct SimpleObjective{T} <: Dispersal.Objective\n\nSimpleObjective(targets)\n\nA basic objective that holds a target array uses the final frame of the simulation as the prediction.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.RegionObjective","page":"Home","title":"Dispersal.RegionObjective","text":"struct RegionObjective{DT, RL, OC, FS, S} <: Dispersal.Objective\n\nImplementation of a loss objective that converts cell data to regional presence/absence and compares to a target of regional occurance data.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.RegionOutput","page":"Home","title":"Dispersal.RegionOutput","text":"mutable struct RegionOutput{T, F<:AbstractArray{T,1}, E, O} <: Output{T}\n\nRegionOutput(init; tspan, objective, [mask], [extent])\n\nA minimal low-memory output that stores the inhabited regions for each timestep, as required by the RegionObjective.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.ColorRegionFit","page":"Home","title":"Dispersal.ColorRegionFit","text":"struct ColorRegionFit{O, T, F, TZ, FZ, M} <: GridProcessor\n\nColorRegionFit(objective, truescheme, falsescheme, falsepositivecolor,\n               truenegativecolor, falsenegativecolor, maskcolor)\n\nAn image procesor for visualising the match between predictions and observed regional occupancy. A live version of the region fitting optimiser.\n\nArguments:\n\nobjective : A RegionObjective object\ntruescheme : ColorSchemes.jl scheme or Greyscale() for true positive fit, etc.\nfalsescheme : ColorSchemes.jl scheme or Greyscale() for true positive fit, etc.\ntruezerocolor : Color, Real beteeen 0.0 and 1.0 or 3 tuple of Real.\nfalsezerocolor : Color, Real beteeen 0.0 and 1.0 or 3 tuple of Real.\nmaskcolor : Color or Real between 0.0 and 1.0 to use when a cell is masked.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.Replicates","page":"Home","title":"Dispersal.Replicates","text":"abstract type Replicates\n\nOptimisation mode for running replicate simulations inside an optimiser.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.DistributedReplicates","page":"Home","title":"Dispersal.DistributedReplicates","text":"struct DistributedReplicates <: Dispersal.Replicates\n\nUse @distributed to run replicate simulations\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.SingleCoreReplicates","page":"Home","title":"Dispersal.SingleCoreReplicates","text":"struct SingleCoreReplicates <: Dispersal.Replicates\n\nUse a single processor to run replicate simulations\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.ThreadedReplicates","page":"Home","title":"Dispersal.ThreadedReplicates","text":"struct ThreadedReplicates <: Dispersal.Replicates\n\nUse Thread.@threads to run replicate simulations\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.targets","page":"Home","title":"Dispersal.targets","text":"targets(obj::Objective)\n\nReturns a targets array given an Objective. The targets must match the size and dimensions of the prediction array returned by predictions.\n\n\n\n\n\n","category":"function"},{"location":"#Dispersal.predictions","page":"Home","title":"Dispersal.predictions","text":"predictions(obj::Objective, output::Output)\n\nMethods that map an objective object and a simulation output to a prediction array.\n\n\n\n\n\n","category":"function"},{"location":"example/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"author: \"Rafael Schouten\" title: \"Dispersal.jl example\" –-","category":"page"},{"location":"example/#Dispersal-simulations","page":"Examples","title":"Dispersal simulations","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"In this example we will run a simulation of the spread of the Spotted Winged Drosophila D. suzukii accross the continental USA.","category":"page"},{"location":"example/#Setup","page":"Examples","title":"Setup","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"First, load the required packages. Dates is a core julia package that give us date/time handling, GeoData simplifies the loading of geospatial raster files. It requires also loading NCDatasets.jl and ArchGDAL.jl to load NetCDF and GeoTiff files, respectively.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"# using Pkg\n# Pkg.add(PackageSpec(url=\"https://github.com/rafaqz/GeoData.jl\", rev=\"master\"))\nusing GeoData, DimensionalData, Dispersal, Dates, NCDatasets, ArchGDAL, Plots","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: ArgumentError: Package GeoData not found in current path:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Run import Pkg; Pkg.add(\"GeoData\") to install the GeoData package.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using DimensionalData: rebuild, Forward, Reverse","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: ArgumentError: Package DimensionalData not found in current path:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Run import Pkg; Pkg.add(\"DimensionalData\") to install the DimensionalData package.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"basedir = joinpath(dirname(Base.pathof(Dispersal)), \"../docs\")","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: Dispersal not defined","category":"page"},{"location":"example/#Define-simulation-extent-in-space-and-time:","page":"Examples","title":"Define simulation extent in space and time:","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"We use DateTime of for the time dimension:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"timestep = Month(1);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: Month not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"tspan = DateTime(2016, 1):Month(1):DateTime(2018, 12)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: DateTime not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"aust = Lon(Between(113.338953078, 153.569469029)),\n       Lat(Between(-43.6345972634, -10.6681857235));","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: Between not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"example/#Define-a-RuleSet:-climate-driven-population-growth","page":"Examples","title":"Define a RuleSet: climate driven population growth","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"This will involve combining multiple dispersal componenents into a single RuleSet object: population growth, local dispersal, Allee effects, and human dispersal.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Follow the examples tutorial over at GrowthRates.jl. To skip this step just download the output saved in the example:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"dataurl = \"https://media.githubusercontent.com/media/cesaraustralia/Dispersal.jl/data\"\ngrowthratesfilename = \"growthrates.ncd\"\ngrowthratesfilepath = joinpath(basedir, growthratesfilename)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: basedir not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"isfile(growthratesfilepath) ||\n  download(joinpath(dataurl, growthratesfilename), joinpath(basedir, growthratesfilename));","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: growthratesfilepath not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"And select just the bounding box for Australia, and set the dimension order to Lat/Lon:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"growthrates = NCDarray(growthratesfilepath)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: NCDarray not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"# Set the length of the timestep. TODO: get this automatically from NetCDF units in GeoData.jl\nti = dims(growthrates, Ti)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: dims not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"mode_ = Sampled(DimensionalData.order(ti), Regular(timestep), Intervals(Start()))","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: DimensionalData not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"growthrates = setdims(growthrates, rebuild(ti; mode=mode_));","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: mode_ not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Plot the growth layer:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"growthrates[Ti(1)] |> plot","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: Ti not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"savefig(joinpath(basedir, \"build/assets/growthrates.png\"));","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: basedir not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Create a ExactLogisticGrowthMap rule from the layer, here we use unitful units for the layers' time dimension:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"carrycap = 1e9\ngrowth = ExactLogisticGrowthMap(layerkey=:growthrates, carrycap=carrycap);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: ExactLogisticGrowthMap not defined","category":"page"},{"location":"example/#Local-dispersal","page":"Examples","title":"Local dispersal","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"λ = 0.0125\nradius = 1\nsze = 2radius + 1\ndm = AreaToArea(30)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: AreaToArea not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"@time hood = DispersalKernel{radius}(;\n    kernel=zeros(Float64, radius, radius),\n    formulation=ExponentialKernel(λ),\n    distancemethod=dm\n)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: DispersalKernel not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"localdisp = InwardsPopulationDispersal(hood);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: InwardsPopulationDispersal not defined","category":"page"},{"location":"example/#Allee-effects","page":"Examples","title":"Allee effects","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"allee = AlleeExtinction(minfounders=10.0);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: AlleeExtinction not defined","category":"page"},{"location":"example/#Human-dispersal","page":"Examples","title":"Human dispersal","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"The human dispersal component is generated from an array or population data. First we'll open an input tiff, and move it to a memory backed GeoArray.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"humanpop_filename = \"population_density.tif\"\nhumanpop_filepath = joinpath(basedir, humanpop_filename)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: basedir not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"isfile(humanpop_filepath) || download(joinpath(dataurl, humanpop_filename), humanpop_filepath);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: humanpop_filepath not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Again select the Australian bounds. This time we also select the first Band. Tiff data always has bands, even when there is only one:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"humanpop = GDALarray(humanpop_filepath; usercrs=EPSG(4326))[Band(1), aust...] |>\n    A -> permutedims(A, (Lat, Lon)) |> reorderarray","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: EPSG not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"savefig(joinpath(basedir, \"build/assets/humanpop.png\"));","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: basedir not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"(Image: popgrowth)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"@time humandisp = HumanDispersal(\n    human_pop=parent(humanpop),\n    human_exponent=2.0,\n    dist_exponent=2.0,\n    dispersalperpop=1e-9,\n    max_dispersers=500.0,\n    nshortlisted=50,\n    scale=8,\n);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: humanpop not defined","category":"page"},{"location":"example/#Define-initialisation-data","page":"Examples","title":"Define initialisation data","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"Make a zeros array and populate the starting cells. We need to replace the missing values with something else Dispersal.jl init can't contain missing or it will spread everywhere:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"init = replace_missing(growthrates[Ti(1)], NaN) |> zero","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: Ti not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"incursion = [(36.9677, -122.0294),\n             (37.3226, -121.8921),\n             (37.6008, -120.9545),\n             (35.3453, -119.0586),\n             (38.7318, -121.9014),\n             (38.5249, -121.9708),\n             (37.2502, -119.751)]\n# Using `Contains` finds the interval that contains the coordinates\nfor (lat, lon) in incursion\n    init[Lat(Contains(lat)), Lon(Contains(lon))] = 1e7\nend","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: Contains not defined","category":"page"},{"location":"example/#Define-a-masking-layer","page":"Examples","title":"Define a masking layer","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"This layer lets the simulation know which cells should be ignored.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"masklayer = boolmask(growthrates[Ti(1)])","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: Ti not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"plot(masklayer)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: plot not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"savefig(joinpath(basedir, \"build/assets/mask.png\"));","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: basedir not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"(Image: mask)","category":"page"},{"location":"example/#Define-a-combined-ruleset","page":"Examples","title":"Define a combined ruleset","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"ruleset = Ruleset(\n    humandisp, Chain(localdisp, allee, growth);\n    timestep=timestep,\n);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: Chain not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"example/#Output","page":"Examples","title":"Output","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"The simplest and oftern the most performant output for a simulation is an ArrayOutput, which simply writes the simulation to a preallocated array without visualising it.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"output = ArrayOutput(init;\n    tspan=tspan,\n    mask=masklayer,\n    aux=(growthrates=growthrates,),\n    minval=0.0,\n    maxval=carrycap,\n);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: growthrates not defined","category":"page"},{"location":"example/#Run-a-simulation","page":"Examples","title":"Run a simulation","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"To run a simulation, we pass in the output and rulset.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"sim!(output, ruleset);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: sim! not defined","category":"page"},{"location":"example/#Save-a-gif-of-your-simulation","page":"Examples","title":"Save a gif of your simulation","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"Gif files are an easy way to share the visual dynamics of the simulation. First we need to define a color processor to turn the simulation into images for the frames of the the gif. This processor can also be used later in web or gtk outputs.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"You can use the built-in Greyscale scheme, or any scheme from ColorSchemes.jl.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using ColorSchemes, Colors\nscheme = ColorSchemes.Oranges_3\n#scheme = ColorSchemes.autumn1\n\n## Frame Processing Colors\nzerocolor = RGB24(0.7)\nmaskcolor = RGB24(0.0)\ntextconfig = TextConfig(font=\"arial\")","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: TextConfig not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"processor = ColorProcessor(scheme, zerocolor, maskcolor, textconfig);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: ColorProcessor not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"With a non-image output like ArrayOuput we need to pass in the image processor manually.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"savegif(joinpath(basedir, \"build/assets/sim.gif\"), output; minval=0.0, maxval=1e7, processor=processor, fps=10);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: basedir not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"(Image: Drosphila suzukii spread)","category":"page"},{"location":"example/#Live-simulation-outputs","page":"Examples","title":"Live simulation outputs","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"There are a number of live outputs provided in CelularAutomataBase.jl and specific output packages DynamicGridsGtk and DynamicGridsInteract that keep heavy graphics and web dependencies separate form the rest of the framework.","category":"page"},{"location":"example/#REPL-output","page":"Examples","title":"REPL output","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"You can view a simulation over SSH or just in your local console using the included REPLOutput. It doesn't work so well in Atom/Juno, so we only recommend using it in a real terminal. It also works better in a terminal where you can easily reduce the font size.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using Crayons","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: ArgumentError: Package Crayons not found in current path:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Run import Pkg; Pkg.add(\"Crayons\") to install the Crayons package.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"output = REPLOutput(init; tspan=tspan, style=Block(), fps=5, color=:white, store=false)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: Block not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"sim!(output, ruleset);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: sim! not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The Braile() style is half the dimensions of the Block() style, but doen't look as clear.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"output = REPLOutput(init; tspan=tspan, style=Braile(), fps=5, color=:white, store=false)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: Braile not defined","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"sim!(output, ruleset);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Error: UndefVarError: sim! not defined","category":"page"},{"location":"example/#Interactive-web-outputs","page":"Examples","title":"Interactive web outputs","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"DynamicGridsInteract.jl produces interactive web page outputs for a simulation. It uses Interact.jl for live control, providing a control console and sliders for model parameters, even for your own custom models.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The simple InteractOutput() is the core output that can run on its own inside Juno or a Jupyter notebook. It can also be served to a browser locally or over the web using ServerOutput(), or run in a standalone desktop app using ElectronOutput().","category":"page"},{"location":"example/#Juno-or-jupyter-notebooks","page":"Examples","title":"Juno or jupyter notebooks","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"Building a InteractOutput() and running display() will open an output in a plot pane in Juno. See the example above to define an image processor. Setting store to true will save the last simulation to the output array to be saved or converted to a gif. Really long simulations may use your avilable ram, in which case set store to false.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"\nusing DynamicGridsInteract\noutput = InteractOutput(init, ruleset;\n    ruleset=ruleset,\n    tspan=tspan,\n    fps=10,\n    store=true,\n    processor=processor,\n    slider_throttle=1.0,\n)\ndisplay(output)","category":"page"},{"location":"example/#Wrap-the-IneractOutput-in-a-standalone-desktop-(electron)-app","page":"Examples","title":"Wrap the IneractOutput in a standalone desktop (electron) app","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"This will create a standalone desktop app wrapping the InteractOutput. Unfortunately the compile and load time for electron can take quite a while.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"\noutput = ElectronOutput(init;\n    ruleset=ruleset,\n    tspan=tspan,\n    fps=10,\n    store=true,\n    processor=processor,\n    slider_throttle=1.0,\n)","category":"page"},{"location":"example/#Serving-web-pages","page":"Examples","title":"Serving web pages","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"The InteractOutput can be served locally or over the web. You may need to do some port or firewall configuration on your server, but otherwise this is all you need to do to serve a simulation. Unlike other outputs, ServerOutput makes a copy of the internal InteractOutput for each new connection. Changes in one connection will not effect anything in the others.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"\noutput = ServerOutput(init;\n    ruleset=ruleset,\n    tspan=tspan,\n    fps=10,\n    processor=processor,\n    slider_throttle=1.0,\n    port=8080,\n)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"If run locally, the interface should be served at the address \"localhost:8080\" in your web browser.","category":"page"},{"location":"example/#Run-in-a-GTK-window","page":"Examples","title":"Run in a GTK window","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"The GTKOutput in DynamicGridsGtk.jl is a simple desktop output that just shows the simulation without controls. It can be useful for faster load-time than ElectronOutput, and also dedicates all screenspace to viewing the simulation.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"\nusing DynamicGridsGtk\noutput = GtkOutput(init .* 0;\n    mask=masklayer,\n    tspan=tspan,\n    fps=10,\n    store=true,\n    processor=processor\n)\nsim!(output, ruleset)","category":"page"}]
}
