var documenterSearchIndex = {"docs":
[{"location":"#Dispersal.jl","page":"Home","title":"Dispersal.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Dispersal","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dispersal","category":"page"},{"location":"#Dispersal.Dispersal","page":"Home","title":"Dispersal.Dispersal","text":"Dispersal.jl\n\n(Image: ) (Image: ) (Image: CI) (Image: codecov.io)\n\n(Image: Spotted wing drosophola dispersal)\n\nA simulation of the spotted-wing drosophola invasion of the continental United  States as detailed in Maino, Schouten, and Umina (2021)\n\nDispersal.jl extends DynamicGrids.jl to provide model components and tools for grid-based simulations of organism dispersal.\n\nGrowth rates, dispersal kernels, Allee effects, and randomised jump and human assisted dispersal rules are provided. These components can be combined into complex dispersal models. Custom rules can easily added and combined with the provided set. See the documentation for examples and the lists of included rules.\n\nDynamicGridsInteract provides an interactive interface for atom and jupyter notbooks (InteractOuput), desktop (ElectronOutput) and online web applications (ServerOuput),  where complete models, including your custom rules, can be manipulated during live simulations.\n\nDynamicGridsGtk provides GtkOutput for a simple graphical viewer.\n\nGrowthMaps.jl can efficiently  generate summarised raster data for vital rates (e.g. intrinsic growth rates) based on  higher resolution and shorter interval environmental data.  \n\n\n\n\n\n","category":"module"},{"location":"#Growth-rules","page":"Home","title":"Growth rules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GrowthRule\nExponentialGrowth\nLogisticGrowth\nThresholdGrowth","category":"page"},{"location":"#Dispersal.GrowthRule","page":"Home","title":"Dispersal.GrowthRule","text":"GrowthRule <: CellRule\n\nAbstract supertype for growth dynamics rules.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.ExponentialGrowth","page":"Home","title":"Dispersal.ExponentialGrowth","text":"ExponentialGrowth <: CellRule\n\nExponentialGrowth(; rate, timestep, [nsteps_type])\nExponentialGrowth{R}(; rate, timestep, [nsteps_type])\nExponentialGrowth{R,W}(; rate, timestep, [nsteps_type])\n\nExponential growth of population size N based on an intrinsic growth rate r, using the exact solution between timesteps t and t-1:\n\nN_t = N_t-1e^r t\n\nKeywords\n\nrate: Intrinsic growth rate. May be a Number, an Aux array or another Grid.\ntimestep: Time step for the growth rate calculation, in a type compatible with the    simulation tspan.\nnsteps_type: Specify the floating point type to use when nsteps is generated from the   timestep, if it is required for type-stability or performance. The default is Float64.\n\nPass grid Symbols to R or both R and W type parameters to use to specific grids.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.LogisticGrowth","page":"Home","title":"Dispersal.LogisticGrowth","text":"LogisticGrowth <: GrowthRule\n\nLogisticGrowth(; rate, carrycap, timestep, [nsteps_type])\nLogisticGrowth{R}(; rate, carrycap, timestep, [nsteps_type])\nLogisticGrowth{R,W}(; rate, carrycap, timestep, [nsteps_type])\n\nLogistic growth rate of population size N based on an intrinsic growth rate r and carry capacity K, using the exact solution between timesteps t+1 and t:\n\nN_t+1 = (N_t K)  (N_t + (K - N_t) e^-rt)\n\nSaturation only applies with positive growth.\n\nKeywords\n\nThese may be a Number, an Aux array or another Grid:\n\nrate: Intrinsic growth rate.\ncarrycap: Carrying capacity.\ntimestep: Time step for the growth rate, in a type compatible with the simulation tspan.\nnsteps_type: Specify the floating point type to use when nsteps is generated from the   timestep, if it is required for type-stability or performance. The default is Float64.\n\nPass grid Symbols to R or both R and W type parameters to use to specific grids.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.ThresholdGrowth","page":"Home","title":"Dispersal.ThresholdGrowth","text":"ThresholdGrowth <: CellRule\n\nThresholdGrowth(; rate, threshold)\nThresholdGrowth{R}(; rate, threshold)\nThresholdGrowth{R,W}(; rate, threshold)\n\nSimple threshold mask. Values below a certain threshold are replaced with zero.\n\nKeywords\n\nThese may be a Number, an Aux array or another Grid.\n\nrate: Intrinsic growth rate.\nthreshold: Minimum viability threshold below which population falls to zero.\n\nPass grid Symbols to R or both R and W type parameters to use to specific grids.\n\n\n\n\n\n","category":"type"},{"location":"#Mortality","page":"Home","title":"Mortality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mortality\nExponentialMortality\nLoglogisticMortality","category":"page"},{"location":"#Dispersal.Mortality","page":"Home","title":"Dispersal.Mortality","text":"Mortality <: CellRule\n\nAbstract super type for rules of survival effect For best performance these should be chained with other CellRule or following an NeighborhoodRule.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.ExponentialMortality","page":"Home","title":"Dispersal.ExponentialMortality","text":"ExponentialMortality <: Mortality\n\nExponentialMortality(; rate, threshold, timestep, [nsteps_type])\nExponentialMortality{R}(; rate, threshold, timestep, [nsteps_type])\nExponentialMortality{R,W}(; rate, threshold, timestep, [nsteps_type])\n\nExponential mortality based on exposure threshold and mortality rate parameter, using exact solution.\n\nExponential mortality based on exposure grid X, an exposure threshold parameter z     and a mortality rate r using exact solution between time t and `t+1:\n\nN_t+1 = N_te^-r t(X-z)\n\nKeywords\n\nrate: Mortality rate.\nthreshold: Exposure threshold under which there is no effect.\ntimestep: Time step for the growth rate, in a type compatible with the simulation tspan.\nnsteps_type: Specify the floating point type to use when nsteps is generated from the   timestep, if it is required for type-stability or performance. The default is Float64.\n\nrate and threshold can be a Number, an Aux array or another Grid`.\n\nPass grid Symbols to R or both R and W type parameters to use to specific grids. R is a 2 Grids NamedTuple like Tuple{:population,:exposure} and W return only the first grid :population.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.LoglogisticMortality","page":"Home","title":"Dispersal.LoglogisticMortality","text":"LoglogisticMortality <: Mortality\n\nLoglogisticMortality(; median, hillcoefficient, timestep, [nsteps_type])\nLoglogisticMortality{R}(; median, hillcoefficient, timestep, [nsteps_type])\nLoglogisticMortality{R,W}(; median, hillcoefficient, timestep, [nsteps_type])\n\nLoglogistic mortality based on median, α and hill coefficient β.\n\nCumulative function of loglogistic: \n\nF(x α β) =  x^β(α^β + x^β)\n\nwhere α0 is the scale and β0 is the shape.\n\nKeywords\n\nmedian: Median of the loglogistic function\nhillcoefficient: Hill's coefficient, a measure of ultrasensitivity (i.e. how steep is the response curve).   May be a Number, an Aux array or another Grid.\ntimestep: Time step for the mortality rate, in a type compatible with the simulation tspan.\n\nPass grid Symbols to R or both R and W type parameters to use to specific grids. R is a 2 Grids NamedTuple like Tuple{:population,:exposure} and W return only the first grid :population.\n\n\n\n\n\n","category":"type"},{"location":"#Allee-effects","page":"Home","title":"Allee effects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AlleeExtinction","category":"page"},{"location":"#Dispersal.AlleeExtinction","page":"Home","title":"Dispersal.AlleeExtinction","text":"AlleeExtinction <: CellRule\n\nAlleeExtinction(minfounders)\nAlleeExtinction{R}(; minfounders=5.0)\nAlleeExtinction{R,W}(minfounders)\n\nCauses extinction in a cell when a population is below a minimum number of individuals.\n\nminfounders: minimum founding individuals required for a viable population.   Must be a type that can be compared to the grid values using isless.\n\nPass grid Symbols to R or both R and W type parameters to use to specific grids.\n\n\n\n\n\n","category":"type"},{"location":"#Local-dispersal-rules","page":"Home","title":"Local dispersal rules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InwardsDispersal\nOutwardsDispersal","category":"page"},{"location":"#Dispersal.InwardsDispersal","page":"Home","title":"Dispersal.InwardsDispersal","text":"InwardsPopulationDispersal <: NeighborhoodRule\n\nInwardsPopulationDispersal(; kw...)\nInwardsPopulationDispersal{R}(; kw...)\nInwardsPopulationDispersal{R,W}(; kw...)\n\nImplements deterministic dispersal from populations in neighboring cells to the current  cell.\n\nThe result should be identical to those obtained substituting InwardsDispersal for  OutwardsDispersal but will perform better when populations are spread across the grid.\n\nKeywords\n\nneighborhood: Any DynamicGrids.jl Neighborhood, or an   already constructed DispersalKernel. Using this keyword means radius is   ignored, and for a DispersalKernel, all other keywords are ignored.\nneighborhood: Neighborhood object specifying the range from the origin of the   discretised dispersal kernal. Defaults to Window(radius).\nformulation: kernel formulation object holding the exact form of the kernal.   Default ExponentialKernel.\ncellsize: the cell size of the discretised kernal (i.e. simulation grid size).   Default is 1.0.\ndistancemethod: DistanceMethod object for calculating distance between cells.   The default is CentroidToCentroid.\n\nPass grid Symbols to R or both R and W type parameters to use to specific grids.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.OutwardsDispersal","page":"Home","title":"Dispersal.OutwardsDispersal","text":"OutwardsPopulationDispersal <: SetNeighborhoodRule\n\nOutwardsPopulationDispersal(; kw...)\nOutwardsPopulationDispersal{R}(; kw...)\nOutwardsPopulationDispersal{R,W}(; kw...)\n\nImplements deterministic dispersal from the current cell to populations in neighboring cells.\n\nThis will make sense ecologically where cell populations are large, otherwise a randomised kernel may be more suitable.\n\nThe result should be identical to those obtained substituting OutwardsDispersal for InwardsDispersal but may be more efficient when a small number of cells are occupied. Conversely, it will become less efficient when a large proportion of the grid is occupied.\n\nKeywords\n\nneighborhood: Any DynamicGrids.jl Neighborhood, or an   already constructed DispersalKernel. Using this keyword means radius is   ignored, and for a DispersalKernel, all other keywords are ignored.\nneighborhood: Neighborhood object specifying the range from the origin of the   discretised dispersal kernal. Defaults to Window(radius).\nformulation: kernel formulation object holding the exact form of the kernal.   Default ExponentialKernel.\ncellsize: the cell size of the discretised kernal (i.e. simulation grid size).   Default is 1.0.\ndistancemethod: DistanceMethod object for calculating distance between cells.   The default is CentroidToCentroid.\n\nPass grid name Symbols to R and W type parameters to use specific grids.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal-kernels","page":"Home","title":"Dispersal kernels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kernels extend DynamicGrids.Neighborhood, and use neighbors() methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DispersalKernel\nKernelFormulation\nExponentialKernel\nGeometricKernel\nGaussianKernel\nWeibullKernel","category":"page"},{"location":"#Dispersal.DispersalKernel","page":"Home","title":"Dispersal.DispersalKernel","text":"DispersalKernel <: AbstractKernelNeighborhood\n\nDispersalKernel(; kw...)\n\nDispersal kernel for taking the dot product of the neighborhood and a matching kernel of weights. May hold any Neighborhood object: the kernel will be built to match the shape, using the folumation, cellsize and distancemethod.\n\nKeyword Arguments\n\nneighborhood: Any DynamicGrids.jl Neighborhood, or an   already constructed DispersalKernel. Using this keyword means radius is   ignored, and for a DispersalKernel, all other keywords are ignored.\nneighborhood: Neighborhood object specifying the range from the origin of the   discretised dispersal kernal. Defaults to Window(radius).\nformulation: kernel formulation object holding the exact form of the kernal.   Default ExponentialKernel.\ncellsize: the cell size of the discretised kernal (i.e. simulation grid size).   Default is 1.0.\ndistancemethod: DistanceMethod object for calculating distance between cells.   The default is CentroidToCentroid.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.KernelFormulation","page":"Home","title":"Dispersal.KernelFormulation","text":"abstract type KernelFormulation\n\nKernelFormulation\n\nAbstract supertype for functors that calculate the probability density based on distance.\n\nConcrete implementations must define functor methods with the form:\n\n(k::SomeKernel)(distance) = # do something with `distance` and `k`\"\n\nUsing an anonymous function would not allow rebuildable model parameters.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.ExponentialKernel","page":"Home","title":"Dispersal.ExponentialKernel","text":"ExponentialKernel <: KernelFormulation\n\nExponentialKernel(λ)\n\nProbability density function of distance d.\n\ny = e^-dλ\n\nwhere λ is a shape parameter.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.GeometricKernel","page":"Home","title":"Dispersal.GeometricKernel","text":"GeometricKernel <: KernelFormulation\n\nGeometricKernel(α)\n\nProbability density function of distance d.\n\nThe Geometric kernel has a power-law decrease.\n\ny = (1+d)^α (α+1)(α+2)  (2 π)\n\nwhere α is a shape parameter.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.GaussianKernel","page":"Home","title":"Dispersal.GaussianKernel","text":"GaussianKernel <: KernelFormulation\n\nGaussianKernel(α)\n\nProbability density function of distance d.\n\ny = 1 (π α^2) e^-d^2α^2 \n\nwhere α is a positive parameter.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.WeibullKernel","page":"Home","title":"Dispersal.WeibullKernel","text":"WeibullKernel <: KernelFormulation\n\nWeibullKernel(α,β)\n\nProbability density function of distance d.\n\ny =β (2 π α^2) d^β-2 e^ -d^βα^β \n\nwhere α and β are positive parameters.\n\n\n\n\n\n","category":"type"},{"location":"#Distance-methods","page":"Home","title":"Distance methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Dispersal kernels can be calculated in a number of ways, giving different  properties and dispersal rates due to interactions between the cell size and the dispersal distance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DistanceMethod\nCentroidToCentroid\nAreaToCentroid\nAreaToArea","category":"page"},{"location":"#Dispersal.DistanceMethod","page":"Home","title":"Dispersal.DistanceMethod","text":"abstract type DistanceMethod\n\nDistanceMethod\n\nAbstract supertype for methods of calculating distances and discretised dispersal  probabilities between cells in a grid. between cells in a grid.\n\nDistance calculation methods include:\n\nCentroidToCentroid\nAreaToArea\nAreaToCentroid\n\nWhich are adapted from: \"On the approximation of continuous dispersal kernels  in discrete-space models, Joseph D. Chipperfield et al 2011\"\n\nThe CentroidToArea method has not been implemented.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.CentroidToCentroid","page":"Home","title":"Dispersal.CentroidToCentroid","text":"struct CentroidToCentroid <: DistanceMethod\n\nCentroidToCentroid <: DistanceMethod\n\nCentroidToCentroid()\n\nCalculates the discrete probability of dispersal between source and destination cell  centroids. This is the naive method, but it will not handle low grid resolution well  due to severe truncation.\n\nSee: \"On the approximation of continuous dispersal kernels in discrete-space models,  Joseph D. Chipperfield et al 2011\"\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.AreaToCentroid","page":"Home","title":"Dispersal.AreaToCentroid","text":"AreaToCentroid <: DistanceMethod\n\nAreaToCentroid(subsampling)\nAreaToCentroid(; subsampling=10.0)\n\nCalculates the discrete probability of dispersal between source cell area and destination centroid.\n\nSee: \"On the approximation of continuous dispersal kernels in discrete-space models,  Joseph D. Chipperfield et al 2011\"\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.AreaToArea","page":"Home","title":"Dispersal.AreaToArea","text":"AreaToArea <: DistanceMethod\n\nAreaToArea(subsampling)\nAreaToArea(; subsampling=10.0)\n\nCalculates the discrete probability of dispersal between source and destination based on  cell areas.\n\nSee: \"On the approximation of continuous dispersal kernels in discrete-space models,  Joseph D. Chipperfield et al 2011\"\n\n\n\n\n\n","category":"type"},{"location":"#Jump-dispersal","page":"Home","title":"Jump dispersal","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JumpDispersal","category":"page"},{"location":"#Dispersal.JumpDispersal","page":"Home","title":"Dispersal.JumpDispersal","text":"JumpDispersal <: SetCellRule\n\nJumpDispersal(; prob_threshold, spotrange)\nJumpDispersal{R}(; prob_threshold, spotrange)\nJumpDispersal{R,W}(; prob_threshold, spotrange)\n\nJump dispersal simulates a random long distance dispersal event, which occurs at a given probablity. A random cell within the spotrange is invaded by duplicating the entire  population of the source cell at the destination cell. \n\nKeyword Arguments\n\nprob_threshold: probability of dispersal, between one and zero.    May be a Number, an Aux array or another Grid:\nspotrange: number of cells in range of jumps, in any direction.\n\nPass grid Symbols to R or both R and W type parameters to use to specific grids.\n\n\n\n\n\n","category":"type"},{"location":"#Human-driven-dispersal","page":"Home","title":"Human driven dispersal","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HumanDispersal\npopulate!\npopulate","category":"page"},{"location":"#Dispersal.HumanDispersal","page":"Home","title":"Dispersal.HumanDispersal","text":"HumanDispersal <: SetCellRule\n\nHumanDispersal{R,W}(; kw...)\n\nImplements human-driven dispersal patterns using population density data.\n\nThe number of long-distance migrants from an origin is set proportional to the level of human population with the coefficient dispersalperpop. The destination of long-distance migration is is calculated by using the distance d between and human population H at origin cell i and destination cell j through a simple gravity function:\n\ng_ij = (H_i H_j)^β(d_ij)^γ\n\nwhere β (human_exponent) and γ (dist_exponent) are parameters. For each grid  cell, a shortlist of size nshortlisted of the destination cells with the highest gravity  are selected for use in the simulation.\n\nThe time taken for precalulation will depend on the scale argument. Values above 1 will downsample the grid to improve precalulation time and runtime performance. A high scale value is good for use in a live interface.\n\nKeywords\n\nmode: Dispersal mode: Defaults to BatchGroups(), otherwise HeirarchicalGroups().\nhuman_pop: An array match the grid size containing human population data.\ncellsize: The size of the cell width, assuming they are square\nscale: Downscaling factor to reduce memory use and improve performance, defaults to 4   which means a 1:16 ratio.\naggregator: a function that aggregates cells, defualting to mean.\nhuman_exponent: human population exponent.\ndist_exponent: distance exponent.\ndispersalperpop: sets the number of dispersing individuals from the origin as a   proportion of the level of human activity.\nmax_dispersers: maximum number of dispersers in a single dispersal event.\nnshortlisted: length of the dispersal destination shortlist for each cell.   Longer lists are more accurate in the tail of the distribution, but are slower to access.\n\nPass grid Symbols to R or both R and W type parameters to use to specific grids.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersal.populate!","page":"Home","title":"Dispersal.populate!","text":"populate!(A::AbstractMatrix, rule::HumanDispersal, [I...])\npopulate!(A::AbstractMatrix, cells::AbstractArray, [scale=1])\n\nPopulate a matrix with the precalculated destinations from a HumanDispersal rule - either all of the or some subset if passed the I... indexing arguments. This is useful for plotting dispersal destinations, especially when used with GeoData.jl\n\n\n\n\n\n","category":"function"},{"location":"#Dispersal.populate","page":"Home","title":"Dispersal.populate","text":"populate(rule::HumanDispersal, [I...])\n\nReturns an array the size of human population matrix filled with all destination locataion, or with destinations specific to the passed-in indices I.\n\n\n\n\n\npopulate(cells::AbstractVector, size::Tuple, [scale::Int=1])\n\nReturns an array of size size populated from the vector of positions in cells rescaled by scale.\n\n\n\n\n\n","category":"function"},{"location":"example/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"author: \"Rafael Schouten\" title: \"Dispersal.jl example\" –-","category":"page"},{"location":"example/#Dispersal-simulations","page":"Examples","title":"Dispersal simulations","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"In this example we will run a simulation of the spread of an invasive insect  accross Australia, after an incursion in Brisbane.","category":"page"},{"location":"example/#Setup","page":"Examples","title":"Setup","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"First, load the required packages. Dates is a core julia package that give us  date/time handling, GeoData and RasterDataSources simplify the loading of geospatial raster files. It requires also loading NCDatasets.jl and ArchGDAL.jl to load NetCDF and GeoTiff files, respectively.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using DynamicGrids\nusing GeoData, NCDatasets, ArchGDAL, RasterDataSources\nusing Dispersal, Dates, Plots, GrowthMaps, Unitful, Statistics\nusing Unitful: °C, K, cal, mol, mm\nbasedir = realpath(joinpath(dirname(Base.pathof(Dispersal)), \"../docs\"))","category":"page"},{"location":"example/#Define-simulation-extent-in-space-and-time:","page":"Examples","title":"Define simulation extent in space and time:","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"We use DateTime of for the time dimension:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"timestep = Month(1);\ntspan = DateTime(2022, 1):timestep:DateTime(2030, 12)\naust = Lon(Between(113, 154)),\n       Lat(Between(-45, -10));","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"example/#Define-a-RuleSet:-climate-driven-population-growth","page":"Examples","title":"Define a RuleSet: climate driven population growth","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"This will involve combining multiple dispersal components into a single RuleSet object: population growth, local dispersal, Allee effects, and human dispersal.","category":"page"},{"location":"example/#Local-dispersal","page":"Examples","title":"Local dispersal","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"localdisp = InwardsDispersal(;\n    radius=1,\n    formulation=ExponentialKernel(; λ = 0.0125),\n    distancemethod=AreaToArea(30),\n)","category":"page"},{"location":"example/#Allee-effects","page":"Examples","title":"Allee effects","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"allee = AlleeExtinction(; minfounders=10.0);","category":"page"},{"location":"example/#Human-dispersal","page":"Examples","title":"Human dispersal","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"The human dispersal component is generated from an array or population data. First we'll open an input tiff, and move it to a memory backed GeoArray.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"humanpop_url = \"https://github.com/cesaraustralia/DSuzukiiInvasionPaper/blob/master/data/population_density.tif?raw=true\"\nhumanpop_filename = \"population_density.tif\"\nhumanpop_filepath = joinpath(basedir, humanpop_filename)\nisfile(humanpop_filepath) || download(humanpop_url, humanpop_filepath);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Again select the Australian bounds. This time we also select the first Band. Tiff data always has bands, even when there is only one:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"humanpop = GDALarray(humanpop_filepath; mappedcrs=EPSG(4326))[Band(1), aust...] |>\n    A -> replace_missing(A, missing) |>\n    A -> permutedims(A, (Lat, Lon)) |> \n    A -> reorder(A, Lat=ReverseArray, Lon=ForwardArray)\nplot(humanpop)\nsavefig(joinpath(basedir, \"build/assets/humanpop.png\"));","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"(Image: popgrowth)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"humandisp = HumanDispersal(\n    human_pop=parent(humanpop),\n    human_exponent=2.0,\n    dist_exponent=2.0,\n    dispersalperpop=1e-9,\n    max_dispersers=500.0,\n    nshortlisted=50,\n    scale=8,\n);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"To obtain spatially and temporally heterogeneous growth rates for our growth model, we simplify the examples tutorial  over at GrowthRates.jl.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"# Generate a growth response curve\np = 3.626804f-01\nΔH_A = 3.586625f4cal/mol\nΔH_H = 1.431237f5cal/mol\nThalf_H = 2.988454f2K\nΔH_L = -1.108988f5cal/mol\nThalf_L = 2.459949f2K\nT_ref = K(25.0f0°C)\ngrowthresponse = Layer(:tavg, °C,\n    SchoolfieldIntrinsicGrowth(p, ΔH_A, ΔH_L, Thalf_L, ΔH_H, Thalf_H, T_ref)\n)\n# Add some lower and upper temperature bounds that cause mortality\ncoldthresh = -10.0f0°C |> K\ncoldmort = -log(1.23f0)K^-1\nheatthresh = 30.0f0°C |> K\nheatmort = -log(1.15f0)K^-1\ncoldstress = Layer(:tavg, °C, LowerStress(coldthresh, coldmort))\nheatstress = Layer(:tavg, °C, UpperStress(heatthresh, heatmort))\n# Set a stressor based on precipitation - there are better data to use\n# for this, but this is easy to download for the example\nwetthresh = 40mm\nwetmort = -0.01f0mm^-1\nwetstress = Layer(:prec, mm, LowerStress(wetthresh, wetmort))\n# Define the whole model\nmodel = growthresponse, coldstress, heatstress, wetstress\n\n# Download some climate data, and reseample to match the population data\nser = map(series(WorldClim{Climate}, (:tavg, :prec); month=1:12)) do stack\n    map(A -> resample(A, humanpop), stack)\nend;\ngrowthrates = mapgrowth(model; series=ser, tspan=1:12)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Plot the growth layer:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"mode_ = Projected(; crs=crs(growthrates), mappedcrs=EPSG(4326))\ngrowthrates = set(growthrates[Band(1)], Lat=mode_, Lon=mode_) |>\n    A -> set(A, Ti(DateTime(2017, 1):Month(1):DateTime(2017, 12))) |>\n    A -> permutedims(A, (Lat, Lon, Ti)) |>\n    A -> reorder(A, Lat=ReverseArray, Lon=ForwardArray)\nplot(growthrates[Ti(5)]; clims=(0, 0.1))\nPlots.savefig(joinpath(basedir, \"build/assets/growthrates.png\"));","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"(Image: popgrowth)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Create a ExactLogisticGrowthMap rule from the layer, here we use unitful units for the layers' time dimension:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"carrycap = 1e9\ngrowth = LogisticGrowth(; rate=Aux(:growthrates), timestep=Day(1), carrycap=carrycap);","category":"page"},{"location":"example/#Define-initialisation-data","page":"Examples","title":"Define initialisation data","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"Make a zeros GeoArray. We need to replace the missing values, as init can't contain missing or it will spread everywhere. We then initialise a population in Brisbane:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"init = replace_missing(humanpop, NaN) |> zero\nlat, lon = -27.5, 153 # Brisbane\ninit[Lat(Contains(lat)), Lon(Contains(lon))] = carrycap","category":"page"},{"location":"example/#Define-a-masking-layer","page":"Examples","title":"Define a masking layer","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"This layer lets the simulation know which cells should be ignored.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"masklayer = boolmask(growthrates[Ti(1)])\nplot(masklayer)\nsavefig(joinpath(basedir, \"build/assets/mask.png\"));","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"(Image: mask)","category":"page"},{"location":"example/#Define-a-combined-ruleset","page":"Examples","title":"Define a combined ruleset","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"ruleset = Ruleset(humandisp, localdisp, allee, growth; timestep=timestep)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"example/#Output","page":"Examples","title":"Output","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"Outputs hold all spatial and temporal information about the simulation, as these match the size and length of the output, making the Ruleset independent of location and time. init, tspan, aux and mask are common to all outputs, here we use the masklayer for mask and growthrates for aux.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Gif files are an easy way to share the visual dynamics of the simulation. GifOutput saves a gif when the simulation finishes.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"You can use the built-in Greyscale scheme or any scheme from ColorSchemes.jl. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using ColorSchemes\noutput = GifOutput(init;\n    # Core keywords\n    tspan=tspan,\n    mask=masklayer,\n    aux=(growthrates=growthrates,),\n    # Visualisation keywords\n    scheme=ColorSchemes.tokyo, fps=10,\n    minval=0.0, maxval=carrycap, \n    filename=joinpath(basedir, \"build/assets/sim.gif\"),\n);","category":"page"},{"location":"example/#Run-a-simulation-and-save-a-gif","page":"Examples","title":"Run a simulation and save a gif","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"To run a simulation, we pass in the output and rulset.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"sim!(output, ruleset);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"(Image: Drosphila suzukii spread)","category":"page"},{"location":"example/#Live-simulation-outputs","page":"Examples","title":"Live simulation outputs","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"There are a number of live outputs provided in DynamicGrids.jl and specific output packages DynamicGridsGtk and DynamicGridsInteract that keep heavy graphics and web dependencies separate form the rest of the framework.","category":"page"},{"location":"example/#REPL-output","page":"Examples","title":"REPL output","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"You can view a simulation over SSH or just in your local console using the included REPLOutput. It doesn't work so well in Atom/Juno, so we only recommend using it in a real terminal. It also works better in a terminal where you can easily reduce the font size.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using Crayons\noutput = REPLOutput(init; \n    mask=masklayer, \n    aux=(growthrates=growthrates,), \n    tspan=tspan, \n    style=Block(), fps=5, color=:white, store=false\n)\nsim!(output, ruleset);","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The Braile() style uses half the space of the Block() style, but won't look as clear.","category":"page"},{"location":"example/#Interactive-web-outputs","page":"Examples","title":"Interactive web outputs","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"DynamicGridsInteract.jl produces interactive web page outputs for a simulation. It uses Interact.jl for live control, providing a control console and sliders for model parameters, even for your own custom models.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The simple InteractOutput() is the core output that can run on its own inside Juno or a Jupyter notebook. It can also be served to a browser locally or over the web using ServerOutput(), or run in a standalone desktop app using ElectronOutput().","category":"page"},{"location":"example/#Juno-or-jupyter-notebooks","page":"Examples","title":"Juno or jupyter notebooks","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"Building a InteractOutput() and running display() will open an output in a plot pane in Juno. See the example above to define an image processor. Setting store to true will save the last simulation to the output array to be saved or converted to a gif. Really long simulations may use your avilable ram, in which case set store to false.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using DynamicGridsInteract\noutput = InteractOutput(init;\n    ruleset=ruleset,\n    tspan=tspan, mask=masklayer, aux=(growthrates=growthrates,),\n    fps=10, store=true, scheme=ColorSchemes.tokyo, \n    minval=0.0, maxval=carrycap,\n    slider_throttle=0.5,\n)\ndisplay(output)","category":"page"},{"location":"example/#Wrap-the-IneractOutput-in-a-standalone-desktop-(electron)-app","page":"Examples","title":"Wrap the IneractOutput in a standalone desktop (electron) app","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"This will create a standalone desktop app wrapping the InteractOutput. Unfortunately the compile and load time for electron can take quite a while.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"output = ElectronOutput(init;\n    ruleset=ruleset,\n    tspan=tspan, mask=masklayer, aux=(growthrates=growthrates,),\n    fps=10, store=true, scheme=ColorSchemes.tokyo, \n    minval=0.0, maxval=carrycap,\n    slider_throttle=1.0,\n)","category":"page"},{"location":"example/#Serving-web-pages","page":"Examples","title":"Serving web pages","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"The InteractOutput can be served locally or over the web. You may need to do some port or firewall configuration on your server, but otherwise this is all you need to do to serve a simulation. Unlike other outputs, ServerOutput makes a copy of the internal InteractOutput for each new connection. Changes in one connection will not effect anything in the others. It tends to flash in Firefox, Chrome may be a better option.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"output = ServerOutput(init;\n    ruleset=ruleset,\n    tspan=tspan, mask=masklayer, aux=(growthrates=growthrates,),\n    fps=10, store=true, scheme=ColorSchemes.tokyo, \n    minval=0.0, maxval=carrycap,\n    slider_throttle=1.0,\n    port=8080,\n)","category":"page"},{"location":"example/#Run-in-a-GTK-window","page":"Examples","title":"Run in a GTK window","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"The GTKOutput in DynamicGridsGtk.jl is a simple desktop output that just shows the simulation without controls. It can be useful for faster load-time than ElectronOutput, and also dedicates all screenspace to viewing the simulation.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using DynamicGridsGtk\noutput = GtkOutput(init;\n    mask=masklayer, aux=(growthrates=growthrates,), tspan=tspan,\n    fps=10, store=true, scheme=ColorSchemes.tokyo, \n    minval=0.0, maxval=carrycap,\n)\nsim!(output, ruleset)","category":"page"}]
}
