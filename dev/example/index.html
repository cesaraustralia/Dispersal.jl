<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · Dispersal.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Dispersal.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Examples</a><ul class="internal"><li><a class="toctext" href="#Setup-1">Setup</a></li><li class="toplevel"><a class="toctext" href="#Define-a-RuleSet-1">Define a RuleSet</a></li><li><a class="toctext" href="#Climate-driven-population-growth-1">Climate driven population growth</a></li><li><a class="toctext" href="#Local-dispersal-1">Local dispersal</a></li><li><a class="toctext" href="#Allee-effects-1">Allee effects</a></li><li><a class="toctext" href="#Human-dispersal-1">Human dispersal</a></li><li><a class="toctext" href="#Define-a-masking-layer-1">Define a masking layer</a></li><li><a class="toctext" href="#Define-a-combined-ruleset-1">Define a combined ruleset</a></li><li class="toplevel"><a class="toctext" href="#Output-1">Output</a></li><li><a class="toctext" href="#Run-a-simulation-1">Run a simulation</a></li><li><a class="toctext" href="#Save-a-gif-of-your-simulation-1">Save a gif of your simulation</a></li><li class="toplevel"><a class="toctext" href="#Live-simulation-outputs-1">Live simulation outputs</a></li><li><a class="toctext" href="#REPL-output-1">REPL output</a></li><li><a class="toctext" href="#Interactive-web-outputs-1">Interactive web outputs</a></li><li><a class="toctext" href="#Run-in-a-GTK-window-1">Run in a GTK window</a></li><li class="toplevel"><a class="toctext" href="#Adding-your-own-rules-1">Adding your own rules</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Examples</a></li></ul><a class="edit-page" href="https://github.com/cesaraustralia/Dispersal.jl/blob/master/docs/src/example.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Examples</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Dispersal-simulations-1" href="#Dispersal-simulations-1">Dispersal simulations</a></h1><p>In this example we will run a simulation of the spread of the Spotted Winged Drosophila <em>D. suzukii</em> accross the continental USA.</p><h2><a class="nav-anchor" id="Setup-1" href="#Setup-1">Setup</a></h2><p>First, load the required packages. Dates is a core julia package that give us date/time handling, GeoData simplifies the loading of geospatial  raster files.</p><pre><code class="language-">using Pkg
Pkg.add(PackageSpec(url=&quot;https://github.com/rafaqz/GeoData.jl&quot;, rev=&quot;master&quot;))
using Dispersal, Dates, GeoData, Plots
using GeoData: Time</code></pre><h3><a class="nav-anchor" id="Define-simulation-settings-1" href="#Define-simulation-settings-1">Define simulation settings</a></h3><p>We use DateTime units of for the timestep:</p><pre><code class="language-">simtimestep = Month(1);</code></pre><h1><a class="nav-anchor" id="Define-a-RuleSet-1" href="#Define-a-RuleSet-1">Define a RuleSet</a></h1><p>This will involve combining multiple dispersal componenents into a single <code>RuleSet</code> object: population growth, local dispersal, Allee effects, and human dispersal.</p><h2><a class="nav-anchor" id="Climate-driven-population-growth-1" href="#Climate-driven-population-growth-1">Climate driven population growth</a></h2><h3><a class="nav-anchor" id="Build-a-growth-rate-matrix-1" href="#Build-a-growth-rate-matrix-1">Build a growth-rate matrix</a></h3><p>Follow the <a href="https://rafaqz.github.io/GrowthRates.jl/dev/example/index.html">examples tutorial</a> over at <a href="https://github.com/rafaqz/GrowthRates.jl">GrowthRates.jl</a>. To skip this step just download the output saved in the example:</p><pre><code class="language-">dataurl = &quot;https://media.githubusercontent.com/media/cesaraustralia/Dispersal.jl/data&quot;
growthratesfilename = &quot;growthrates.ncd&quot;
if !isfile(growthratesfilename)
    download(joinpath(dataurl, growthratesfilename))
end
growthrates = GeoArray(NCDarray(&quot;growthrates.ncd&quot;))</code></pre><p>Plot the growth layer:</p><pre><code class="language-">using Plots
plot(growthrates[Time(1)])
savefig(&quot;build/assets/growthrates.png&quot;)</code></pre><p>Create a <code>ExactLogisticGrowthMap</code> rule from the layer, here we use unitful units for the layers&#39; <code>Time</code> dimension:</p><pre><code class="language-">carrycap = 1e8
growth = ExactLogisticGrowthMap(layer=growthrates, carrycap=carrycap);</code></pre><h2><a class="nav-anchor" id="Local-dispersal-1" href="#Local-dispersal-1">Local dispersal</a></h2><pre><code class="language-">lambda = 0.0125
radius = 1
sze = 2radius + 1
dm = AreaToArea(30)
@time hood = DispersalKernel{radius}(;kernel=zeros(Float64, radius, radius),
                               formulation=ExponentialKernel(lambda), distancemethod=dm)
localdisp = InwardsPopulationDispersal(hood)
display(hood.kernel * carrycap);</code></pre><h2><a class="nav-anchor" id="Allee-effects-1" href="#Allee-effects-1">Allee effects</a></h2><pre><code class="language-">allee = AlleeExtinction(minfounders=10.0);</code></pre><h2><a class="nav-anchor" id="Human-dispersal-1" href="#Human-dispersal-1">Human dispersal</a></h2><p>The human dispersal component is generated from an array or population data. First we&#39;ll open an input tiff, and move it to a memory backed <code>GeoArray</code>. </p><pre><code class="language-">humanpopfilename = &quot;population_density.tif&quot;
if !isfile(humanpopfilename)
    download(joinpath(dataurl, humanpopfilename))
end
human_pop = GDALarray(humanpopfilename)[Band(1), Lon(590:1125), Lat(150:480)]
size(growthrates)
dims(human_pop)
window = Lat(Between(bounds(growthrates, Lat))), Lon(Between(bounds(growthrates, Lon))) 
plot(human_pop[window...])
plot(growthrates[window...][Time(1)])

savefig(&quot;build/assets/human_pop.png&quot;)</code></pre><p><img src="../assets/popgrowth.png" alt="popgrowth"/></p><pre><code class="language-">scale = 8
human_exponent = 2.0
dist_exponent = 2.0
dispersalperpop = 1e-9
max_dispersers = 500.0
shortlist_len = 100
@time humandisp = HumanDispersal(parent(human_pop); scale=scale, shortlist_len=shortlist_len, dispersalperpop=dispersalperpop,
                                 max_dispersers=max_dispersers, human_exponent=human_exponent,
                                 dist_exponent=dist_exponent, timestep=simtimestep);</code></pre><h3><a class="nav-anchor" id="Define-initialisation-data-1" href="#Define-initialisation-data-1">Define initialisation data</a></h3><p>Make a zeros array and populate the starting cells:</p><pre><code class="language-">init = zero(growthrates[Time(1), Band(1)])

incursion = [(36.9677,-122.0294),
             (37.3226,-121.8921),
             (37.6008,-120.9545),
             (35.3453,-119.0586),
             (38.7318,-121.9014),
             (38.5249,-121.9708),
             (37.2502,-119.751)]

# Using `Near` finds the nearest cell to the coordinates
for (lat, lon) in incursion 
    init[Lat(Near(lat)), Lon(Near(lon))] = 1e7 
end</code></pre><h2><a class="nav-anchor" id="Define-a-masking-layer-1" href="#Define-a-masking-layer-1">Define a masking layer</a></h2><p>This layer lets the simulation know which cells should be ignored.</p><pre><code class="language-">masklayer = BitArray(mask(growthrates[Time(1), Band(1)]))
heatmap(masklayer)
savefig(&quot;build/assets/mask.png&quot;)</code></pre><p><img src="../assets/mask.png" alt="mask"/></p><h2><a class="nav-anchor" id="Define-a-combined-ruleset-1" href="#Define-a-combined-ruleset-1">Define a combined ruleset</a></h2><pre><code class="language-">ruleset = Ruleset(humandisp, Chain(localdisp, allee, growth); 
                  init=init, 
                  mask=masklayer, 
                  timestep=simtimestep, 
                  minval=0.0, 
                  maxval=carrycap);</code></pre><h1><a class="nav-anchor" id="Output-1" href="#Output-1">Output</a></h1><p>The simplest and most performant output for a simulation is an ArrayOutput, which simply writes the simulation to a preallocated array without visualising it.  </p><pre><code class="language-">tstop = 100
output = ArrayOutput(init, tstop) </code></pre><h2><a class="nav-anchor" id="Run-a-simulation-1" href="#Run-a-simulation-1">Run a simulation</a></h2><p>To run a simulation, we pass in the output and rulset.</p><pre><code class="language-"># FIXME: this hangs
# sim!(output, ruleset)</code></pre><h2><a class="nav-anchor" id="Save-a-gif-of-your-simulation-1" href="#Save-a-gif-of-your-simulation-1">Save a gif of your simulation</a></h2><p>Gif files are an easy way to share the visual dynamics of the simulation. First we need to define a color processor to turn the simulation into images for the frames of the the gif. This processor can also be used later in web or gtk outputs.</p><p>You can use the built-in <code>Greyscale</code> scheme, or any scheme from <a href="https://github.com/JuliaGraphics/ColorSchemes.jl">ColorSchemes.jl</a>.</p><pre><code class="language-">using ColorSchemes
#scheme = ColorSchemes.autumn1
scheme = ColorSchemes.Oranges_3

## Frame Processing Colors
zerocolor = RGB24(0.7) 
maskcolor = RGB24(0.0)
processor = ColorProcessor(scheme, zerocolor, maskcolor);</code></pre><p>With a non-image output like ArrayOuput we need to pass in the image processor manually.</p><pre><code class="language-">savegif(&quot;build/assets/sim.gif&quot;, output, ruleset, processor; fps=10)</code></pre><p><img src="../assets/sim.gif" alt="Drosphila suzukii spread"/></p><h1><a class="nav-anchor" id="Live-simulation-outputs-1" href="#Live-simulation-outputs-1">Live simulation outputs</a></h1><p>There are a number of live outputs provided in CelularAutomataBase.jl and specific output packages DynamicGridsGtk and DynamicGridsInteract that keep heavy graphics and web dependencies separate form the rest of the framework.</p><h2><a class="nav-anchor" id="REPL-output-1" href="#REPL-output-1">REPL output</a></h2><p>You can view a simulation over SSH or just in your local console using the included <code>REPLOutput</code>. It doesn&#39;t work so well in Juno, so we only recommend using it in a real terminal. It also works better in a terminal where you can easily reduce the font size.</p><pre><code class="language-">using Crayons
output = REPLOutput(init; style=Block(), fps=5, color=:white, store=false)</code></pre><p>The <code>Braile()</code> style is half the dimensions of the <code>Block()</code> style, but doen&#39;t look as clear.</p><pre><code class="language-">output = REPLOutput(init; style=Braile(), fps=5, color=:white, store=false)</code></pre><h2><a class="nav-anchor" id="Interactive-web-outputs-1" href="#Interactive-web-outputs-1">Interactive web outputs</a></h2><p><a href="http://gihub.com/rafaqz/DynamicGridsInteract.jl">DynamicGridsInteract.jl</a> produces interactive web page outputs for a simulation. It uses Interact.jl for live control, providing a control console and sliders for model parameters, even for your own custom models.</p><p>The simple <code>InteractOutput()</code> is the core output that can run on its own inside Juno or a Jupyter notebook. It can also be served to a browser locally or over the web using <code>ServerOutput()</code>, or run in a standalone desktop app using <code>ElectronOutput()</code>.</p><h3><a class="nav-anchor" id="Juno-or-jupyter-notebooks-1" href="#Juno-or-jupyter-notebooks-1">Juno or jupyter notebooks</a></h3><p>Building a <code>InteractOutput()</code> and running <code>display()</code> will open an output in a plot pane in Juno. See the example above to define an image processor. Setting <code>store</code> to true will save the last simulation to the output array to be saved or converted to a gif. Really long simulations may use your avilable ram, in which case set <code>store</code> to false.</p><pre><code class="language-">using DynamicGridsInteract
output = InteractOutput(init, ruleset; fps=10, store=true, processor=processor, slider_throttle=1.0)
display(output)</code></pre><h3><a class="nav-anchor" id="Wrap-the-IneractOutput-in-a-standalone-desktop-(electron)-app-1" href="#Wrap-the-IneractOutput-in-a-standalone-desktop-(electron)-app-1">Wrap the IneractOutput in a standalone desktop (electron) app</a></h3><p>This will create a standalone desktop app wrapping the InteractOutput. Unfortunately the compile and load time for electron can take quite a while.</p><pre><code class="language-">output = ElectronOutput(init, ruleset; fps=10, store=true, processor=processor, slider_throttle=1.0)</code></pre><h3><a class="nav-anchor" id="Serving-web-pages-1" href="#Serving-web-pages-1">Serving web pages</a></h3><p>The <code>InteractOutput</code> can be served locally or over the web. You may need to do some port or firewall configuration on your server, but otherwise this is all you need to do to serve a simulation. Unlike other outputs, <code>ServerOutput</code> makes a copy of the internal <code>InteractOutput</code> for each new connection. Changes in one connection will not effect anything in the others.</p><pre><code class="language-">output = ServerOutput(init, model; port=8000, fps=10, processor=processor, slider_throttle=1.0)</code></pre><h2><a class="nav-anchor" id="Run-in-a-GTK-window-1" href="#Run-in-a-GTK-window-1">Run in a GTK window</a></h2><p>The <code>GTKOutput</code> in <a href="http://gihub.com/rafaqz/DynamicGridsGtk.jl">DynamicGridsGtk.jl</a> is a simple desktop output that just shows the simulation without controls. It can be useful for faster load-time than <code>ElectronOutput</code>, and also dedicates all screenspace to viewing the simulation.</p><pre><code class="language-">using DynamicGridsGtk
output = GtkOutput(init .* 0; fps=10, store=true, processor=processor)</code></pre><h1><a class="nav-anchor" id="Adding-your-own-rules-1" href="#Adding-your-own-rules-1">Adding your own rules</a></h1><p>In Dispersal.jl and the CelularAutomataBase.jl framework it&#39;s easy to add your won custom model components, or &#39;rules&#39; to follow the language of cellular automata. If you write them well they will perform as well as the built in rules, and can take advantage of a number of the same performance optimisations by using the type heirarchy in DynamicGrids.jl. </p><p>Rules may be a [number of types]. </p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a></footer></article></body></html>
