---
title : Dispersal.jl example
author : Rafael Schouten
---

# Dispersal simulations

In this example we will run a simulation of the spread of the Spotted Winged
Drosophila _D. suzukii_ accross the continental USA.

## Setup

First, load the required packages. Dates is a core julia package that
give us date/time handling, GeoData simplifies the loading of geospatial
raster files. It requires also loading NCDatasets.jl and ArchGDAL.jl to load
NetCDF and GeoTiff files, respectively.

```{julia; results="hidden"}
using GeoData, NCDatasets, ArchGDAL, RasterDataSources
using Dispersal, Dates, Plots, GrowthMaps, Unitful, Statistics
using Unitful: °C, K, cal, mol, mm
basedir = realpath(joinpath(dirname(Base.pathof(Dispersal)), "../docs"))
```

### Define simulation extent in space and time:

We use `DateTime` of for the time dimension:

```{julia; results="hidden"}
timestep = Month(1);
tspan = DateTime(2016, 1):timestep:DateTime(2018, 12)
aust = Lon(Between(113.338953078, 153.569469029)),
       Lat(Between(-43.6345972634, -10.6681857235));
```

---

### Define a `RuleSet`: climate driven population growth

This will involve combining multiple dispersal components into a single
`RuleSet` object: population growth, local dispersal, Allee effects, and human
dispersal.

### Local dispersal

```{julia; results="hidden"}
localdisp = InwardsDispersal(;
    radius=1,
    formulation=ExponentialKernel(; λ = 0.0125),
    distancemethod=AreaToArea(30),
)
```

### Allee effects

```{julia; results="hidden"}
allee = AlleeExtinction(; minfounders=10.0);
```

### Human dispersal

The human dispersal component is generated from an array or population data.
First we'll open an input tiff, and move it to a memory backed `GeoArray`.

```{julia; results="hidden"}
humanpop_url = "https://github.com/cesaraustralia/DSuzukiiInvasionPaper/blob/master/data/population_density.tif?raw=true"
humanpop_filename = "population_density.tif"
humanpop_filepath = joinpath(basedir, humanpop_filename)
isfile(humanpop_filepath) || download(humanpop_url, humanpop_filepath);
```

Again select the Australian bounds. This time we also select the first Band.
Tiff data always has bands, even when there is only one:

```{julia; results="hidden"}
humanpop = GDALarray(humanpop_filepath; mappedcrs=EPSG(4326))[Band(1), aust...] |>
    A -> replace_missing(A, missing) |>
    A -> permutedims(A, (Lat, Lon)) |> 
    A -> reorder(A, ForwardIndex) |>
    A -> reorder(A, ForwardArray)
plot(humanpop)
savefig(joinpath(basedir, "build/assets/humanpop.png"));
```

![popgrowth](assets/humanpop.png)


```{julia; results="hidden"}
humandisp = HumanDispersal(
    human_pop=parent(humanpop),
    human_exponent=2.0,
    dist_exponent=2.0,
    dispersalperpop=1e-9,
    max_dispersers=500.0,
    nshortlisted=50,
    scale=8,
);
```

To obtain spatially and temporally heterogeneous growth rates for our growth model,
we simplify the [examples tutorial](https://rafaqz.github.io/GrowthRates.jl/dev/example/index.html) 
over at [GrowthRates.jl](https://github.com/rafaqz/GrowthRates.jl).

```{julia; results="hidden"}
# Generate a growth response curve
p = 3.626804f-01
ΔH_A = 3.586625f4cal/mol
ΔH_H = 1.431237f5cal/mol
Thalf_H = 2.988454f2K
ΔH_L = -1.108988f5cal/mol
Thalf_L = 2.459949f2K
T_ref = K(25.0f0°C)
growthresponse = Layer(:tavg, °C,
    SchoolfieldIntrinsicGrowth(p, ΔH_A, ΔH_L, Thalf_L, ΔH_H, Thalf_H, T_ref)
)
# Add some lower and upper temperature bounds that cause mortality
coldthresh = -10.0f0°C |> K
coldmort = -log(1.23f0)K^-1
heatthresh = 30.0f0°C |> K
heatmort = -log(1.15f0)K^-1
coldstress = Layer(:tavg, °C, LowerStress(coldthresh, coldmort))
heatstress = Layer(:tavg, °C, UpperStress(heatthresh, heatmort))
# Set a stressor based on precipitation - there are better data to use
# for this, but this is easy to download for the example
wetthresh = 40mm
wetmort = -0.01f0mm^-1
wetstress = Layer(:prec, mm, LowerStress(wetthresh, wetmort))
# Define the whole model
model = growthresponse, coldstress, heatstress, wetstress

tspan = DateTime(2017,1):Month(1):DateTime(2017,12)
# Download some climate data, and reseample to match the population data
ser = map(series(WorldClim{Climate}, (:tavg, :prec); month=1:12)) do stack
    map(A -> resample(A, humanpop), stack)
end;
growthrates = mapgrowth(model; series=ser, tspan=1:12)
```

Plot the growth layer:

```{julia; results="hidden"}
mode_ = Projected(; crs=crs(growthrates), mappedcrs=EPSG(4326))
growthrates = set(growthrates[Band(1)], Lat=mode_, Lon=mode_) |>
    A -> set(A, Ti(DateTime(2017, 1):Month(1):DateTime(2017, 12))) |>
    A -> permutedims(A, (Lat, Lon, Ti)) |>
    A -> reorder(A, ForwardIndex) |>
    A -> reorder(A, ForwardArray)
plot(growthrates[Ti(5)]; clims=(0, 0.1))
heatmap(parent(growthrates[Ti(1)]))
heatmap(parent(humanpop))

Plots.savefig(joinpath(basedir, "build/assets/growthrates.png"));
```

Create a `ExactLogisticGrowthMap` rule from the layer, here we use
unitful units for the layers' time dimension:

```{julia; results="hidden"}
carrycap = 1e9
growth = LogisticGrowth(; rate=Aux(:growthrates), timestep=Day(1), carrycap=carrycap);
```

### Define initialisation data

Make a zeros `GeoArray` and populate the starting cells. We need to replace the `missing`
values with something else Dispersal.jl init can't contain `missing` or it will spread everywhere:

```{julia; results="hidden"}
init = replace_missing(humanpop, NaN) |> zero
incursion = [
    (-36.9677, 122.0294),
    (-37.3226, 121.8921),
    (-37.6008, 120.9545),
    (-35.3453, 119.0586),
    (-38.7318, 121.9014),
    (-38.5249, 121.9708),
    (-37.2502, 119.751),
]
for (lat, lon) in incursion
    init[Lat(Near(lat)), Lon(Contains(lon))] = 1e7
end
```

### Define a masking layer

This layer lets the simulation know which cells should be ignored.

```{julia; results="hidden"}
masklayer = boolmask(growthrates[Ti(1)])
plot(masklayer)
savefig(joinpath(basedir, "build/assets/mask.png"));
```

![mask](assets/mask.png)

### Define a combined ruleset

```{julia; results="hidden"}
ruleset = Ruleset(humandisp, localdisp, allee, growth; timestep=timestep)
```

---

## Output

The simplest and oftern the most performant output for a simulation is an
ArrayOutput, which simply writes the simulation to a preallocated array
without visualising it.

```{julia; results="hidden"}
output = ArrayOutput(init;
    tspan=tspan,
    mask=masklayer,
    aux=(growthrates=growthrates,),
    minval=0.0, maxval=carrycap,
);
```

### Run a simulation

To run a simulation, we pass in the output and rulset.

```{julia; results="hidden"}
sim!(output, ruleset);
```

### Save a gif of your simulation

Gif files are an easy way to share the visual dynamics of the simulation. First
we need to define a color processor to turn the simulation into images for the
frames of the the gif. This processor can also be used later in web or gtk
outputs.

You can use the built-in `Greyscale` scheme, or any scheme from
[ColorSchemes.jl](https://github.com/JuliaGraphics/ColorSchemes.jl).

```{julia; results="hidden"}
using ColorSchemes
```

With a non-image output like ArrayOuput we need to pass in the image processor
manually.

```{julia; results="hidden"}
savegif(joinpath(basedir, "build/assets/sim.gif"), output; 
    minval=0.0, maxval=1e7, scheme=ColorSchemes.Oranges_3, fps=10
);
```

![Drosphila suzukii spread](assets/sim.gif)


## Live simulation outputs

There are a number of live outputs provided in DynamicGrids.jl and
specific output packages DynamicGridsGtk and DynamicGridsInteract that keep
heavy graphics and web dependencies separate form the rest of the framework.

### REPL output

You can view a simulation over SSH or just in your local console using the
included `REPLOutput`. It doesn't work so well in Atom/Juno, so we only recommend
using it in a real terminal. It also works better in a terminal where you can
easily reduce the font size.

```{julia; results="hidden"}
using Crayons
output = REPLOutput(init; 
    mask=masklayer, aux=(growthrates=growthrates,), tspan=tspan, 
    style=Block(), fps=5, color=:white, store=false
)
sim!(output, ruleset);
```

The `Braile()` style uses half the space of the `Block()` style, but won't look as clear.

### Interactive web outputs

[DynamicGridsInteract.jl](http://gihub.com/rafaqz/DynamicGridsInteract.jl)
produces interactive web page outputs for a simulation. It uses Interact.jl for
live control, providing a control console and sliders for model parameters, even
for your own custom models.

The simple `InteractOutput()` is the core output that can run on its own inside Juno
or a Jupyter notebook. It can also be served to a browser locally or over the
web using `ServerOutput()`, or run in a standalone desktop app using
`ElectronOutput()`.

### Juno or jupyter notebooks

Building a `InteractOutput()` and running `display()` will open an output in a plot
pane in Juno. See the example above to define an image processor. Setting
`store` to true will save the last simulation to the output array to be saved or
converted to a gif. Really long simulations may use your avilable ram, in which
case set `store` to false.

```{julia; eval=false}
using DynamicGridsInteract
output = InteractOutput(init, ruleset;
    ruleset=ruleset,
    tspan=tspan,
    fps=10,
    store=true,
    processor=processor,
    slider_throttle=0.5,
)
display(output)
```

### Wrap the IneractOutput in a standalone desktop (electron) app

This will create a standalone desktop app wrapping the InteractOutput. Unfortunately
the compile and load time for electron can take quite a while.

```{julia; eval=false}
output = ElectronOutput(init;
    ruleset=ruleset,
    tspan=tspan,
    fps=10,
    store=true,
    processor=processor,
    slider_throttle=1.0,
)
```

### Serving web pages

The `InteractOutput` can be served locally or over the web. You may need to do some
port or firewall configuration on your server, but otherwise this is all you
need to do to serve a simulation. Unlike other outputs, `ServerOutput` makes a
copy of the internal `InteractOutput` for each new connection. Changes in one
connection will not effect anything in the others.

```{julia; eval=false}
output = ServerOutput(init;
    ruleset=ruleset,
    tspan=tspan,
    fps=10,
    processor=processor,
    slider_throttle=1.0,
    port=8080,
)
```

If run locally, the interface should be served at the address "localhost:8080" in your web browser.

### Run in a GTK window

The `GTKOutput` in
[DynamicGridsGtk.jl](http://gihub.com/rafaqz/DynamicGridsGtk.jl) is a
simple desktop output that just shows the simulation without controls. It can be
useful for faster load-time than `ElectronOutput`, and also dedicates all
screenspace to viewing the simulation.

```{julia; eval=false}
using DynamicGridsGtk
output = GtkOutput(init .* 0;
    mask=masklayer,
    tspan=tspan,
    fps=10,
    store=true,
    processor=processor
)
sim!(output, ruleset)
```
